[
  {
    "chunk_id": 1,
    "text": "To be able to split the incoming data stream into individual records the record size must be calculated. The record size calculation is managed by the record options terminated_by , static_size , and dynamic_size , and includes the termination character. The different ways to calculate the size are tried in the following order: If the record is a sub-record (a field of another record) and the parent external field size is specified, this size is used. How field sizes are calculated depends on the external type of the parent record type. A typical case appears if an ASN.1/BER type contains a sequential subtype, in which case the BER size specification is used. If the static_size option is specified, this size is used. If the dynamic_size option is specified, this value is calculated and used. If the terminated_by option is specified, the input stream is scanned until the terminator is found (this implies that no field can contain this terminator since the first occurrence is seen as the end of the UDR). The record size includes the termination character but never takes up more than the total remaining size in the UDR. If everything else fails, an attempt to calculate the size is made by summarizing the total size of all content declarations. terminated_by The function terminated_by identifies how a record is terminated. Records can be terminated by a byte constant or EOF (end of file). The constant can be declared numerically (decimal or hexadecimal), or as a plain ASCII char. In the latter case, the literal must be enclosed in quotes. Note! Only one byte is allowed. Example - Using terminated_by Record termination by constant: external myExternal : terminated_by(0xA) { // <contents declaration> }; external myExternal : terminated_by(';') { // <contents declaration> }; Record termination by end of file: external demoExt : terminated_by(EOF) { // <contents declaration> ascii remainingData : dynamic_size( remaining_size ); }; dynamic_size Binary encodings that vary in size often contain a field with information on their specific length. In these cases, the dynamic_size declaration may be used, specifying how to calculate the record size from the values of one or more fields. Example - dynamic_size external myExternal : dynamic_size(recordLength) { int RecordLength : static_size(2); // <continued contents declaration> }; static_size Records of fixed size are declared using static_size . Example - static_size external myExternal : static_size(<recordLength>) { // <contents declaration> }; identified_by If the identified_by option is present, it specifies the condition under which a record of this type is present in the stream. This is used when the input data contains different record types, in which case the decoder uses the identified_by expression to evaluate if the data matches the record type. The condition is also evaluated when deciding whether to use a specific out map during encoding. Example - identified_by external myUDRType1 : identified_by( udrType == 1 ) { int udrType : static_size(1); // <continued contents declaration> };",
    "title": "Record Declaration - MediationZone Documentation 9.3 - InfoZone",
    "url": "https://infozone.atlassian.net/wiki/spaces/MD93/pages/204646864/Record+Declaration",
    "word_count": 483,
    "char_count": 3088
  }
]