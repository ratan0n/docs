[
  {
    "chunk_id": 1,
    "text": "MediationZone uses internal formats to represent data entities that it can process. All processing agents (for instance, Analysis and Aggregation) work with these internal formats. A syntax for the internal format is declared as follows: internal <name> [: (<class specifications> | <format inheritance>) ] { <field_type> <field_name> [:optional] ; ... }; The field types may be any of the following: Field Type Description Field Type Description any Any type. bigint Big integer. bigdec Big decimal. boolean Boolean. bytearray Byte array. byte Integer type (8-bit signed). char Integer type (16-bit unsigned). short Integer type (16-bit signed). int Integer type (32-bit signed). long Integer type (64-bit signed). float Float type (32-bit). double Float type (64-bit). date Date type, with capability to hold date parts, time parts, or both. bitset A set of bits. ipaddress An IP address. drudr An instance of any other internal (all internal are drudr instances). string String. The field_type can also be any other internal or list type that is defined in either the same ultra file or in another. See the example below. Example - Internal formats Case 1: internal I1 { I2 f1; }; internal I2 { list<int> f1; }; Case 2: In file A internal I1 { <foldername>.<filename>.I2 f1; //When referring an internal from another file that is in the same folder, the folder name can be omitted. }; In file B internal I2 { list<int> f1; }; List types are declared as follows: list< ElementType > Where ElementType can be any of the previous, including an internal format identifier, or another list type. Example - List type internal I1 { list<list<I2> > f1; }; It is also possible to specify a field as optional: Example - Specifying a field as optional internal I1 { drudr f1: optional; }; Similarly, you declare a map field type this way: map< ElementType, ElementType > Example - Declaring a map field internal I1 { map<string, int> f1; }; Internal formats can also be automatically generated from in_map definitions. For further information, see target_internal specification in In-maps . Class Specifications All internal formats are compiled into Java classes. It is possible to specify additional interfaces for the class to implement: Example - Class specifications internal I1 : implements(\"Interface1\"), implements(\"Interface2\") { ... }; However, this requires that Interface1 and Interface2 only declare methods that are later generated by Ultra when it creates the Java class. For further information about methods and types for UDR type methods, see the Development Toolkit user's guide . Format Inheritance You can use alternative base UDR definitions for the generated Ultra classes by using the extends_class or extends option, but all UDR types cannot be used as an extension base. Except for UDR types defined in Ultra, only some specific agent UDRs are extendible, and session UDR types can not be used. extends_class is used by some agents (for instance, the HTTP agent) for better processing support. Example - extends_class internal I1 : extends_class( com.mysite.myDTKUltraFormat ) { ... }; The extends option lets a format inherit fields defined in an ancestor. Example - extends internal A { int a; ... }; internal B : extends ( A ) { int b; ... }; Multiple inheritances is not supported, meaning you can only use the extends or extends_class option once in the definition of an internal format. Event Types It is possible to declare user-defined event types in Ultra by using the event keyword instead of internal . Such an event is a special type of internal format with added event processing support.",
    "title": "Internal Formats - MediationZone Documentation 9.3 - InfoZone",
    "url": "https://infozone.atlassian.net/wiki/spaces/MD93/pages/204612847",
    "word_count": 587,
    "char_count": 3619
  }
]