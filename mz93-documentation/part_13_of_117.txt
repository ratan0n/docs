# RATANON/MZ93-DOCUMENTATION - Part 13/112

---
**Dataset:** ratanon/mz93-documentation
**Part:** 13 of 112
**GitHub:** https://github.com/ratan0n/docs/tree/main/mz93-documentation
**Size:** ~57.5 KB
---

# Document 271: SFTP Agents Preparations - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204740522
**Categories:** chunks_index.json

Prior to configuring an SFTP agent, consider the following preparation notes: Server Identification Attributes Authentication Server Keys Server Identficiation The SFTP agent uses a file with known host keys to validate the server identity during connection setup. The location and naming of this file is managed through the Execution Context property: mz.ssh.known_hosts_file It is set in the <pico name> .conf file of the relevant EC to manage where the file is saved. The default value is ${mz.home}/etc/ssh/known_hosts . The SSH implementation uses JCE (Java Cryptography Extension), which means that there may be limitations on key sizes for your Java distribution. This is usually not a problem. However, there may be some cases where the unlimited strength cryptography policy is needed. For instance, if the host RSA keys are larger than 2048 bits (depending on the SSH server configuration). This may require that you update the Java Platform that runs the EC. For unlimited strength cryptography on the Oracle JRE, download the JCE Unlimited Strength Jurisdiction Policy Files from http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html . Replace the jar files in $JAVA_HOME/jre/lib/security with the files in this package. The OpenJDK JRE does not require special handling of the JCE policy files for unlimited strength cryptography. Attributes he SFTP collection agent and the SFTP forwarding agent share a number of common attributes. They are both supported by a number of algorithms: 3des-cbc, 3des-ctr, blowfish-cbc, aes128-cbc, aes192-cbc, aes256-cbc, aes128-ctr, aes192-ctr, aes256-ctr. Authentication The SFTP agents support authentication through either username/password or private key. Private keys can optionally be protected by a Key password. Most commonly used private key files, can be imported into the system. Typical command line syntax (most systems): ssh-keygen -t <keyType> -f <directoryPath> Setting Description Setting Description keyType The type of key to be generated. Both RSA and DSA key types are supported. directoryPath The directory in which you want to save the generated keys. Example - Creating a private key The private key may be created using the following command line: > ssh-keygen -t rsa -f /tmp/keystore Enter passphrase: xxxxxx Enter same passphrase again: xxxxxx Then the following is stated: Your identification key has been saved in /tmp/keystore Your public key has been saved in /tmp/keystore.pub When the keys are created the private key may be imported to the SFTP agent. To import the private key into the SFTP agent: Open the Agent Configuration dialog for the SFTP collection agent as described in SFTP Collection Agent Configuration . Authenticate with Private Key . Click on the Select... button to open the Edit Private Key dialog. Paste your private key into the text field. Enter your password in the Password field and click OK . Close the Agent Configuration dialog by clicking OK . Open Finally, on the SFTP server host, append /tmp/keystore.pub to $HOME/.ssh/authorized_keys . If the $HOME/.ssh/authorized_keys is not there it must be created. Server Keys The SSH protocol uses host verification as protection against attacks where an attacker manages to reroute the TCP connection from the correct server to another machine. Since the password is sent directly over the encrypted connection, it is critical for security that an incorrect public key is not accepted by the client. The agent uses a file with the known hosts and keys. It will accept the key supplied by the server if either of the following is fulfilled: The host is previously unknown. In this case the public key will be registered in the file. The host is known and the public key matches the old data. The host is known however has a new key and the user has been configured to accept the new key. For further information, see the Advanced tab. If the host key changes for some reason, the file will have to be removed (or edited) in order for the new key to be accepted.

---

# Document 272: UDR Views - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204646825/UDR+Views
**Categories:** chunks_index.json

Open the UDR View configuration by clicking the UDR View button in the UDR File Editor . See UDR File Editor for more information. The UDR View opens up in a new tab in your browser. In the UDR View configuration you can define how UDR data is listed and presented in the UDR File Editor and the Aggregation Session Inspector . Open UDR File Editor with no UDR View applied To create a UDR View configuration: In the UDR View configuration, click Browse... to open the UDR Internal Format Browser dialog. Select the UDR type you want to create a view for and click OK . Click the Add button to open another view of the UDR Internal Format Browser dialog. Select the field in the selected UDR you want to add to the view, click Apply and repeat for all fields you want to add. Click OK or Cancel to close the dialog. You can now rearrange the order of the fields by selecting them and clicking the Up and Down buttons. When your view is finished, click Save As to save your UDR View. In the UDR File Editor you can now select the saved UDR View to display the configured fields as columns in the order you have specified. Open UDR File Editor with a UDR View A UDR View does not have to be applicable to all UDR types within a displayed file. If a field does not exist for a particular UDR, n o such field is displayed.

---

# Document 273: FTP NMSC Agent - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205000246/FTP+NMSC+Agent
**Categories:** chunks_index.json

This section describes the FTP NMSC collection agent. This agent is for batch workflow configurations. Prerequisites The reader of this information should be familiar with the: Nokia SMS Center Billing Interface Nokia MMS Center Billing Interface The FTP/NMSC collection agent collects data files from SMS / MMS Center and inserts them into a workflow by using the FTP protocol. To do this, two control files must be read and validated. The NMSC agent uses two control files to handle the state of the data files. The agent collects data files according to the specifications in the storage control file. For every successfully collected data file the agent updates a corresponding record in the transaction control file. The section contains the following subsections: FTP NMSC Agent Configuration FTP NMSC Agent Transaction Behavior FTP NMSC Agent Input/Output Data and MIM Agent Message Events

---

# Document 274: Aggregation Example - Association of IP Data - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204606151
**Categories:** chunks_index.json

To illustrate the Aggregation agent's features, an association example according to the following workflow setup is presented below. The workflow is handling IP traffic data, and will group information from routers and the corresponding network access servers. Open An example where an Aggregation agent is used to associate IP data The Netflow agent collects router data and logs the interacting network elements' addresses and amount of bytes handled, while the Radius agent keeps track of who has initiated the connection, and for how long the connection was up. Thus, each user login session consists of two Radius UDRs (start and stop), and one or several Netflow UDRs. The Aggregation agent is used to associate this data from each login session. These additional rules apply: A Radius UDR belonging to a specific login session must always arrive before its corresponding Netflow UDRs. If a Netflow UDR arrives without a preceding Radius UDR, it must be deleted. Within a Netflow UDR, the user initiating the session may act as a source or destination, depending on the direction of data transfer. Thus, it is important to match the IP address from the Radius UDRs with source or destination IP from the Netflow UDRs. Note! The Radius specific response handling will not be discussed in this example. For further information, see Radius Agents . Session Definition For each session, all the necessary data must be saved. A suggestion of useful variables for this scenario is described below. Note! The input UDRs are not stored. Information from the UDRs is extracted and saved in the session variables. The Ultra definition for the session type: session ExampleSession { string user; string IPAddress; long sessionID; long downloadedBytes; long uploadedBytes; }; Variable Description Variable Description user The user initiating the network connection. This value is fetched from the start of Radius UDR. IPAddress The IP address of the user initiating the network connection. This value is fetched from the start Radius UDR. sessionID A unique ID grouping a specific network connection session for the specific user. This value is fetched from the start Radius UDR. downloadedBytes The amount of downloaded bytes according to information extracted from Netflow UDRs. uploadedBytes The amount of uploaded bytes according to information extracted from Netflow UDRs. Association - Radius UDRs The Radius UDRs are the Aggregation session-initiating units. They may be of two types in this example; start or stop. Open The Aggregation profile - Association tab - Radius UDRs This is how arriving Radius UDRs are evaluated when configured according to the figure The Aggregation Profile - Association Tab - Radius UDRs: Initially, the UDR is evaluated against the Primary Expression. If it evaluates to false , all further validation is interrupted and the UDR will be deleted without logging (since no more rules exist). Usually, invalid UDRs are set to be deleted. In this case, only the UDRs of type start ( acctStatusType=1 ) or stop ( acctStatusType=2 ) are of interest. If the Primary Expression evaluation was successful, the field Framed_IP_Address entered in the ID Fields area, together with the Additional Expression (if any) are used as secondary verification. If it evaluates to true , the UDR will be added to the session, if not - refer to the subsequent step. Create Session on Failure is the final setting. It indicates if a new session will be created if no matching session has been found in Step 2. Association - Netflow UDRs As previously mentioned, the IP address to match against in the Netflow UDRs depends on if data is being uploaded or downloaded. This results in the session initiator being either the source or destination. Hence, both these fields need to be evaluated in the Aggregation agent: Open The Aggregation profile - Association tab - Netflow UDRs This is how arriving Netflow UDRs are evaluated when configured according to the figure The Aggregation Profile Editor - Association Tab - Netflow UDRs: If the DestinationIP, situated in the ID Fields area in the first Rules tab, does not match any existing session, and no new session is created. If a match is found, the UDR is associated with this session. Regardless of the outcome of the first rule, all rules are always evaluated. Hence the second rule is evaluated. If the SourceIP situated in the ID Fields area in the second Rules tab does not match any existing session, no new session is created. If a match is found, the UDR is associated with this session. The APL Code From the APL code (the agent configuration dialog), all actions related to both initiating and matching a session are defined. When a session is considered associated, the session variables are saved in a new UDR Type ( outputUDR ( out )) containing fields with the same name as the variables. Note! The timeout of a session is set to five days from the current date. Outdated sessions are removed and their data is transferred to a UDR of type outputUDR , which is sent to ECS. import ultra.Example.Out; sessionInit { Accounting_Request_Int radUDR = (Accounting_Request_Int) input; session.user = radUDR.User_Name; session.IPAddress = radUDR.framedIPAddress; session.sessionID = radUDR.acctSessionId; } consume { /* Radius UDRs. If a matching session is found, then there are two Radius UDRs and the session is considered completed. Remove session and route the new UDR. */ if (instanceOf(input, Accounting_Request_Int)) { Accounting_Request_Int radUDR = (Accounting_Request_Int)input; if (radUDR.acctStatusType == 2 ) { OutputUDR finalUDR = udrCreate( OutputUDR ); finalUDR.user = session.user; finalUDR.IPAddress = (string)session.IPAddress; finalUDR.downloadedBytes = session.downloadedBytes; finalUDR.uploadedBytes = session.uploadedBytes; udrRoute( finalUDR ); sessionRemove(session); return; } } /* Netflow UDRs. Depending on if the user downloaded or uploaded bytes, the corresponding field data is used to update session variables. */ if (instanceOf(input, V5UDR)) { V5UDR nfUDR = (V5UDR)input; if ( session.IPAddress == nfUDR.SourceIP ) { session.downloadedBytes = session.downloadedBytes + nfUDR.BytesInFlow; } else { session.uploadedBytes = session.uploadedBytes + nfUDR.BytesInFlow; } } // A session will be considered outdated in 5 days. date timer=dateCreateNow(); dateAddDays( timer, 5 ); sessionTimeout( session, timer ); } timeout { // Outdated sessions are removed, and a resulting UDR is sent on. OutputUDR finalUDR = udrCreate( OutputUDR ); finalUDR.user = session.user; finalUDR.IPAddress = (string)session.IPAddress; finalUDR.downloadedBytes = session.downloadedBytes; finalUDR.uploadedBytes = session.uploadedBytes; udrRoute( finalUDR ); sessionRemove(session); }

---

# Document 275: SAP CC Batch Agent in Real-Time Workflows - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204609082/SAP+CC+Batch+Agent+in+Real-Time+Workflows
**Categories:** chunks_index.json

This section describes how to configure the SAP CC Batch agent in real-time workflows, and contains the following subsections: SAP CC Batch Agent Configuration - Real-Time SAP CC Batch Agent Input/Output Data and MIM - Real-Time SAP Batch Agent Events - Real-Time

---

# Document 276: Legacy KafkaOffsetUDR - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/301138729/Legacy+KafkaOffsetUDR
**Categories:** chunks_index.json

The KafkaOffsetUDR is used to determine an offset that is not at the beginning or the end of the collection and that only applies if you have selected Start at requested in the Kafka Collection agent configuration. The Kafka Collection agent waits for the KafkaOffsetUDR and does not consume before the offset information. Messages can be persisted to a database or aggregation agent. Note! If you send a KafkaOffsetUDR from initialize without any content, messages are read from the beginning (from the first offset). The following fields are included in the KafkaOffsetUDR : Field Description Field Description offsets (map<int,long>) This field is populated with offset information. As offsets in Kafka are unique per partition, this maps partition identifiers (int) to an offset (long). offsetsAsString (string) This field contains a comma-separated key-value list and is available as a convenience. It is used for populating with offset information, as it provides a simple way to store the map with partitions and offset as a string. It reads and writes the same underlying data as the offsets (map<int,long>) field so that changing the value of offsetsAsString (string) changes the value of offsets (map<int,long>) and vice versa. Example An example of two partitions as string type: 1=2,2=3

---

# Document 277: Workflow Group States - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204605010/Workflow+Group+States
**Categories:** chunks_index.json

When a workflow group is executed and stopped depends on its configuration as well as on events that occur while running. To understand how a workflow group operates, see the state diagram below and the detailed description of the different states that follows. Open The Workflow Group state diagram State Description State Description Aborted The default behavior is that a workflow group does not assume the Aborted state until all of its members are back to Idle. When one member is in the Aborted state, the workflow continues until all the other members in the workflow group have finished execution. Then the workflow group gets into an Aborted state. Note! You can change the default behavior by using the Behavior when member abort settings in the Execution tab, see Execution in Managing a Workflow Group . When you stop a workflow group, it first assumes the Stopping state and takes care of all transactions. When this is done, the workflow group state changes to Idle. Hold A workflow group that is in the Idle state while being imported - either by the mzsh systemimport r | sr | sir | wr or by the System Importer configured to Hold Execution - enters the Hold state until the import activity is finished. The workflow group then resumes its Idle state. Idle The workflow group configuration is valid , and none of its members is currently being executed from within the workflow group. Invalid There is an error in the workflow group configuration. Note! The workflow group cannot be executed in the Invalid state. Running The workflow group is running, controlling the execution of its members according to the configuration settings. Stopping A manual stop of the workflow group, or of the parent workflow group, makes the workflow group enter the Stopping state. The workflow group remains in the Stopping state while all the members are finishing their data transactions. Then the workflow group goes into either the Idle or the Aborted state. Suppressed Workflow groups that are in the Running state while configurations are being imported - either by the mzsh systemimport r | sr | sir | wr command, or by the System Importer configured to Hold Execution - enter the Suppressed state. In this state any scheduled members are prevented from being started. The workflow group remains in this state until the import activity is finished. Then, if the workflow members are still running, the real-time workflow group returns to the Running state. Batch workflow groups remain in the Suppressed state until their members complete their execution. Then, the workflow group state becomes Idle. Note! If the workflow group is in the Suppressed state, and you stop all the workflow group members, the workflow group enters the Stopping state. If this happens while an import process is going on, the workflow group moves from the Stopping state to the Idle state, and then to the Hold state.

---

# Document 278: DropDown UDR - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205034979/DropDown+UDR
**Categories:** chunks_index.json

The DropDown UDR is used to add a dropdown element on a page enabling you to select one item from a list of many. Open The following fields are included in the DropDown UDR : Field Description Field Description attributes (map<string,string>) This field may contain extra attributes to be added. cssClasses (list<string>) This field may contain a list of extra values added to the class attribute. This is typically used to style the component. Please read more on Bootstrap . disabled (boolean) This field may contain a boolean if the component should be disabled or enabled. id (string) This field may contain the id of the component items (map<string,string>) This field must contain a map of key-value pairs. The key will be present in UI and the value will be set on the Value attribute. This means the value will be sent if the dropbox is submitted in a Form UDR. To get the items in the same order as added the map needs to be created with mapCreateOrdered function. label (string) This field may contain the label for the dropdown. labelCssClasses (list<string>) This field may contain a list of extra values added to class attribute of the label. This is typically used to style the component. Please read more on Bootstrap . name (string) This field may contain the name of the component. If the component is present in a Form UDR , the name will be submitted with the form as the key in the Params Map in Request UDR . selected (string) This field may contain a string matching a value in the Items map. If a match is found this Item will be selected in the dropdown.

---

# Document 279: Base Event - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205030500/Base+Event
**Categories:** chunks_index.json

A Base event is the parent of all events, except for the user defined events. Since it is the parent it means that all events will inherit the fields of the base event . Note! Subscribing to base events is not recommended since it will match every event produced in the system, which may generate a high volume of events. Base events contains the following information: category - Not utilized for Base event. contents - A hard coded string containing event specific information; the original event message. For instance, for the ECS Insert Event, this string will contain the type of data sent to ECS, the workflow name, the agent name, and the UDR count. For information about the contents field, see the specific event types (this table). eventName - The name of the Event, that is, any of the types described in this section, for example, Base event, Code Manager event or Alarm event. origin - The IP address of one of the following: Execution Context - On which the workflow that issues the event is running. Platform - If this is not a Workflow event. Desktop - If this is a User Event. receiveTimeStamp - The date and time for when an event is inserted in the platform database. For example, this is the time used in the System Log. severity - The severity of the event. May be any of: Information, Warning, Error or Disaster. The default value is Information. timeStamp - The date and time taken from the host where the event is issued.

---

# Document 280: wfenable - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204646626/wfenable
**Categories:** chunks_index.json

usage: wfenable <pattern match expression for workflow names> ... This command enables one or more workflows. With this command you compare a single pattern match expression, or several, with the full workflow name, <folder>.<workflowconfigurationname>.<workflowname> , of all the workflows. The command accepts standard wild cards, such as '*' and '?'. For further information see Textual Pattern Matches . Return Codes Listed below are the different return codes for the wfenable command: Code Description 0 Will be returned if the command was successful. 1 Will be returned if the argument count is incorrect. 2 Will be returned if the user is not found or not logged in. 3 Will be returned if no matching workflow was found.

---

# Document 281: Extract Database Definition Files for Oracle - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205029581/Extract+Database+Definition+Files+for+Oracle
**Categories:** chunks_index.json

When Oracle and MediationZone are not installed on the same machine (the database may be installed on any machine within the network), the database definition files need to be transferred to the Oracle machine before the database can be created. On the Oracle machine (as oracle UNIX user): transfer the database-setup.tar file from the machine and extract the files: $ tar -xvf ./database-setup.tar Enter the database directory $ cd database

---

# Document 282: UI Builder Agent Events - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204643521/UI+Builder+Agent+Events
**Categories:** chunks_index.json

Agent Message Events There are no message events for this agent. Debug Events Debug messages are dispatched in debug mode. During execution, the messages are displayed in the Workflow Monitor. You can configure Event Notifications that are triggered when a debug message is dispatched. For further information about the debug event type, see Debug Event . The agent produces the following debug events: Message Description Message Description Request processed and routed. drUIBuilderContextID: <number> This message is displayed when the UI Builder agent receives a request. drUIBuilderContextID is used to determine the corresponding response by the UI Builder Agent as well as an identifier for the Cycle(UIBuilder) UDR that is being processed in the APL. Response sent. DrUIBuilderContextID: <number> This message is displayed when the UI Builder agent sends out the response. DrUIBuilderContextID is used to identify the preceding request that was received by the UI Builder Agent.

---

# Document 283: Diameter XML Specification Syntax - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204640890/Diameter+XML+Specification+Syntax
**Categories:** chunks_index.json

This section describes the tags used in the XML file and includes a DTD file that supports the XML file. Example - XML Specification file CCR and CCA command specifications for the Diameter Credit-Control application (Nortel GGSN): ccr_cca.xml XML The XML file of the Diameter agent contains the following tags: 1.1 Example - XML Specification file 2 <diameter-protocol> 2.1 Example - diameter-protocol syntax 3 <avp> 3.1 Example - avp syntax 4 <flag-rules> 4.1 Example - flag-rules syntax 5 <flag-rule> 5.1 Example - flag-rule syntax 6 <may-encrypt> 6.1 Example - may-encrypt syntax 7 <simple-type> 7.1 Example - simple-type syntax 8 <enumeration> 8.1 Example - enumeration syntax 9 <enumerator> 10 <layout> 10.1 Example - layout syntax 11 <fixed> 12 <required> 13 <optional> 14 <avp-ref> 15 <any-avp> 16 <command> 16.1 Example - command syntax 17 <answer> 17.1 Example - answer syntax 18 <header-bits> 18.1 Example - header-bits syntax 19 <header-bit> <diameter-protocol> The XML file starts with a diameter-protocol declaration. Example - diameter-protocol syntax <diameter-protocol name='unknown'> The name attribute is optional and specifies the diameter protocol name. The diameter-protocol tag can contain the following tags: <avp> <command> <avp> The AVP tag defines an AVP. Example - avp syntax <avp id='55' name='Event-Timestamp' vendor='1234'> Each AVP tag requires an ID and a name. The ID is the AVP code allocated by IANA for this AVP. The name identifies this AVP in grouped AVPs or commands. The vendor attribute is optional and sets the ID of the AVP vendor. The AVP tag must contain the following tag. <flag-rules> The AVP tag must contain one of the following tags. <simple-type> <enumeration> <layout> The AVP tag may contain the following tag. <may-encrypt> <flag-rules> The flag-rules tag is required for the AVP tag and defines the AVP flags with a number of flag-rule definition tags. Example - flag-rules syntax <flag-rules> <flag-rule name='mandatory' rule='must'/> <flag-rule name='protected' rule='must_not'/> </flag-rules> <flag-rule> The flag-rule tag defines the value for one of the valid AVP flags. Example - flag-rule syntax <flag-rule name='mandatory' rule='must'/> The flag-rule tag has two required attributes. The name attribute is the flag name, either mandatory or protected. The rule attribute defines the flag value and can be must , may , should_not or must_not . <may-encrypt> The may-encrypt tag defines if this AVP is to be encrypted or not. Example - may-encrypt syntax <may-encrypt/> <simple-type> <simple-type> with its name attribute defines the AVP type as any of the following types: Unsigned32 Unsigned64 Signed32 Signed64 Float32 Float64 DiameterIdentity UTF8String Address OctetString Time DiameterURI IPFilterRule Example - simple-type syntax <simple-type name='Time'/> <enumeration> The enumeration tag defines AVPs of type Enumerated and can have any number of <enumerator> sub-tags. Example - enumeration syntax <enumeration> <enumerator value='1' name='EVENT_RECORD'/> <enumerator value='2' name='START_RECORD'/> <enumerator value='3' name='INTERIM_RECORD'/> <enumerator value='4' name='STOP_RECORD'/> </enumeration> <enumerator> The enumerator tag defines an element in an Enumerated AVP type. It has two required attributes called name and value. For an example of the syntax see the section above, <enumeration> . <layout> The layout tag defines AVPs of type Grouped. A grouped AVP consists of a sequence of AVPs. It is also possible to nest grouped AVPs, that is to include a grouped AVP within a grouped AVP Example - layout syntax <layout> <fixed> <avp-ref name='Session-Id' min='0'/> </fixed> <required> <avp-ref name='Origin-Host'/> <avp-ref name='Origin-Realm'/> <avp-ref name='Result-Code'/> </required> <optional> <avp-ref name='Origin-State-Id'/> <avp-ref name='Error-Reporting-Host'/> <avp-ref name='Error-Message'/> <avp-ref name='Proxy-Info' max='*'/> <any-avp/> </optional> </layout> The layout tag can contain the following tags. <fixed> <required> <optional> <fixed> The fixed tag defines the fixed AVPs included in a grouped AVP. For an example of the syntax see the layout syntax example in the section above, <layout> . The fixed tag can contain the following tag. <avp-ref> <required> The required tag defines the required AVPs included in a grouped AVP. For an example of the syntax see the example, layout syntax in the section above, <layout> . The required tag can contain the following tags. <avp-ref> <any-avp> <optional> The optional tag defines the optional AVPs included in a grouped AVP. For an example of the syntax see the example, layout syntax in the section above, <layout> . The optional tag can contain the following tags. <avp-ref> <any-avp> <avp-ref> The avp-ref tag contains a reference to an AVP that should be included in a grouped AVP. The tag has a required attribute called name . It holds the name of the referenced AVP. The optional attributes min and max set the qualifiers for the AVP. For an example of the syntax, see the example, layout syntax, in the section above, <layout> . <any-avp> The any-avp tag defines that a grouped AVP in the group list can have any number of AVPs of any kind. <command> The command tag defines a command. Example - command syntax <command id='257'> The required attribute id is the command code allocated by IANA for this command. The optional attribute application sets the command application ID. The command tag requires one of the following tags. <answer> <request> <answer> This tag defines an answer command. The attribute name is required. Example - answer syntax <answer name='Error-Answer-Message'> The answer tag can contain the following tags. <header-bits> <layout> <header-bits> This tag defines the header bits of a command. Example - header-bits syntax <header-bits> <header-bit name='request' value='0'/> <header-bit name='proxiable' value='1'/> <header-bit name='error' value='1'/> </header-bits> The header-bits tag can contain the following tags. <header-bit> <header-bit> This tag defines a command header bit. For an example of the syntax, see the example, header-bits syntax, in the section above, <header-bits> . The header-bit tag has two required attributes. name is the header bit name and can be request , proxiable or error . The value is the bit value (0 or 1). Any other value will cause the XML aborter to abort with an error message. DTD diameter.dtd supports the XML file in the section above, XML. <?xml version='1.0' encoding='ascii'?> <!ELEMENT diameter-protocol (avp|command)*> <!ATTLIST diameter-protocol name CDATA #REQUIRED> <!ELEMENT avp (flag-rules,enumeration?,layout?)> <!ATTLIST avp id CDATA #REQUIRED> <!ATTLIST avp name CDATA #REQUIRED> <!ATTLIST avp datatype CDATA #IMPLIED> <!ATTLIST avp vendor CDATA #IMPLIED> <!ELEMENT flag-rules (flag-rule*)> <!ELEMENT flag-rule EMPTY> <!ATTLIST flag-rule name CDATA #REQUIRED> <!ATTLIST flag-rule rule CDATA #REQUIRED> <!ELEMENT enumeration (enumerator*)> <!ELEMENT enumerator EMPTY> <!ATTLIST enumerator value CDATA #REQUIRED> <!ATTLIST enumerator name CDATA #REQUIRED> <!ELEMENT layout (fixed?,required?,optional?)> <!ELEMENT fixed (avp-ref*)> <!ELEMENT required (avp-ref*,any-avp?)> <!ELEMENT optional (avp-ref*,any-avp?)> <!ELEMENT avp-ref EMPTY> <!ATTLIST avp-ref name CDATA #REQUIRED> <!ATTLIST avp-ref min CDATA #IMPLIED> <!ATTLIST avp-ref max CDATA #IMPLIED> <!ELEMENT any-avp EMPTY> <!ELEMENT command (request?, answer?)> <!ATTLIST command id CDATA #REQUIRED> <!ATTLIST command application CDATA #IMPLIED> <!ENTITY % command-children "(header-bits, layout)"> <!ELEMENT request %command-children;> <!ATTLIST request name CDATA #REQUIRED> <!ELEMENT answer %command-children;> <!ATTLIST answer name CDATA #REQUIRED> <!ELEMENT header-bits (header-bit*)> <!ELEMENT header-bit EMPTY> <!ATTLIST header-bit value CDATA #REQUIRED>

---

# Document 284: Pico Viewer - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204741981
**Categories:** chunks_index.json

The Pico Viewer displays a list of all Pico clients currently online in the system. Pico clients are grouped in pico-started instances. For instance, ec1 in the figure below is a pico-started instance. To open the Pico Viewer, click the Tools button in the upper left part of the Desktop window, and then select Pico Viewer from the menu. Open Pico Viewer Columns Description Columns Description Group / Instance Name of the group and pico instance. For each pico instance, they will be assigned to a default group for that particular pico instance. For example, any Desktop will be assigned to the Desktop group. For any ECs that are not assigned to an EC Group, they will be assigned into the Execution Contexts group by default. For more details about EC group and what it is used for, refer to EC Groups . Delete Open Allows the user to remove a pico instance from the system in case it is unreachable. The Platform does not automatically unregister such an instance since it is accepted that it can reside on an unreliable network. Secure Indicates if the Pico instance is SSL secured or not. Start Time The time the pico instance was started. Memory Used, available, and maximum memory on the hosting JVM. Response [ms] The time it took in milliseconds for the local Desktop to invoke a ping on the pico instance. Marked for Shutdown A warning sign in this column indicates that a pico instance is marked for shutdown, via the mzsh command pico , and should not be assigned workflows. This column is only applicable to ECs. For further information about the pico command, see pico . Tool-Tip Information Hover the mouse over any pico instances folder in the Group / Instance column to display information on the OS, JVMs, architecture, and processors on which it is running, as well as the username and services. Open The tooltip of a pico instance Hover the mouse over any pico instances folder in the Memory column to display detailed information on the memory usage of the hosting JVM. Open The tooltip of memory usage

---

# Document 285: Form UDR - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204643632
**Categories:** chunks_index.json

The Form UDR is used to create a form that includes other components where you can enter data to be sent to workflow. Open Example of a simple form with one TextField and one Button You can use the following APL code to create a form as shown above: //Create the Form UDR Form searchform = udrCreate(Form); searchform.method = searchform.METHOD_POST; //Create the textfield to be included in the form. TextField searchText = udrCreate(TextField); searchText.id = "search"; //Must include name otherwise the data can not be sent to workflow searchText.name = "search"; searchText.placeholder = "Filter Results"; //Create the send button Button searchButton = udrCreate(Button); searchButton.buttonType = searchButton.SUBMIT; searchButton.text = "Search"; //Add the components to the form searchform.components = listCreate(ComponentUDR, searchText, searchButton); Another example of a form that uses a grid to place the components. Open Example of a form using grid The APL code to produce the above example is this: Example of APL code // Helper functions for column and row GridColumn getColumn(ComponentUDR comp, int width){ GridColumn col = udrCreate(GridColumn); if(width > 0){ col.width = width; } col.components = listCreate(ComponentUDR, comp); return col; } GridRow getRow(list<GridColumn> columns){ GridRow row = udrCreate(GridRow); row.columns = listCreate(GridColumn); for (GridColumn column: columns) { listAdd(row.columns, column); } return row; } The following fields are included in the Form UDR : Field Description Field Description action (string) This field may contain a string that specifies where to send the form data when a form is submitted. Possible values: An absolute URL - points to another web site (like " http://www.example.com/example.htm ") A relative URL - points to a url within the web site (like "example") attributes (map<string,string>) This field may contain extra attributes to be added. components (list<ComponentUDR>) This field may contain a list of child components, the components that will produce the form data. They can be added direct in the list or inside a Grid UDR and then the Grid UDR is added here. cssClasses (list<string>) This field may contain a list of extra values added to class attribute. This is typically used to style the component. Please read more on Bootstrap . encoding (string) This field may contain may a string for encoding. Some constants is added to help: URL_ENCODED , TEXT_PLAIN , MULTIPART Default is URL_ENCODED. id (string) This field may contain the id of the component method (int) This field may contain method used to submit the form. Possible values are: METHOD_GET , METHOD_POST . Default is METHOD_GET. name (string) This field may contain the name of the component

---

# Document 286: Oracle - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204737654
**Categories:** chunks_index.json

This section contains information that is specific to the database type Oracle. Supported Functions The Oracle database can be used with: Audit Profile Callable Statements (APL) Database Bulk Lookup Functions (APL) Database Table Related Functions (APL) Database Collection/Forwarding Agents Data Masking Profile Event Notifications Prepared Statements (APL) Data Veracity Shared Table Profile SQL Collection/Forwarding Agents Task Workflows Agents (SQL) Properties When selecting the Oracle database type, you can configure the following properties using the Properties tab in the Database profile: oracle.pool.connectionwaittimeout oracle.pool.maxlimit oracle.net.encryption_client oracle.net.encryption_types_client oracle.net.crypto_checksum_client oracle.net.crypto_checksum_types_client Preparations A database driver is required to connect to an Oracle database. This driver must be stored in the Platform Container. Follow these if Oracle was not set up during the installation of the Platform Container: Download the JDBC driver ( ojdbc<version>.jar ) for the appropriate Oracle database version, and the ONS.jar driver in the case you use Oracle RAC. Copy the downloaded file(s) to the directory MZ_HOME/3pp in the Platform Container. Restart the Platform and ECs for the change to take effect. You should be able to select the Oracle option from the Database profile after this step. Advanced Connection Configuration for Oracle RAC The Advanced Connection Setup is used for Oracle RAC Configurations. To make the Connection String text area and the Notification Service text field appear, select the General radio button. The Username , Password, and Database Type fields will remain. If MediationZone is installed with the Oracle database, the Oracle RAC functionality Fast Connection Failover (FCF) is available. MediationZone supports FCF thus, the expectation is that there will normally be some exceptions generated during RAC instance failover. When FCF is configured, the system detects a lost connection, clears the database connection pool, and reinitializes the connection pool. During a RAC instance failover, you might experience exceptions, for example, when database transactions such as updates and inserts are done. Database exceptions are logged in the system. The Platform and Execution Contexts support the failover behavior. However, note that neither database collection nor forwarding agents support FCF. These agents have different types of database connection pool implementation. Open Database Profile Configuration - Advanced Connection Setup Setting Description Setting Description Connection String In the text field, a connection string can be entered. The connection string can contain a SID or a service name. The string added will not be modified by the underlying system. If a connection string is longer than the text area spaces a vertical scroll bar will be displayed to enable viewing and editing of the connection string. Notification Service Enter the Configuration that enables the Oracle Notification Service daemon (ONS) to establish a Fast Connection Failover (FCF). The ONS string that you enter should at least specify the agent ONS configuration attribute, which is made up of a comma-separated list of host:port pairs. The hosts and ports represent the remote ONS daemons that are available on the RAC agents. For further information see the Installation guidelines for Oracle RAC in the Installation Instructions .

---

# Document 287: Data Protection and Privacy Guide - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/407601363/Data+Protection+and+Privacy+Guide
**Categories:** chunks_index.json

This is the Data Protection and Privacy (DPP) guide for MediationZone. This document is designed to assist you in understanding and implementing the necessary data protection measures when configuring personal data processing within MediationZone. As you implement the configurations and workflows necessary for your projects, this guide will serve as a resource for best practices and efficient data management strategies within MediationZone. 1 Data Protection Enabling Agents in MediationZone 1.1 Data Masking Agent 1.2 Encryption Agent 2 Guidelines for DPP compliance in workflows 2.1 Archiving Agent, Profile and Inspector 2.2 Amazon S3 Forwarding Agent 2.3 Data Veracity Forwarding Agent 2.4 Error Correction System 2.5 SQL Forwarding & Processing Agents 2.6 Disk Forwarding Agent 2.7 Database Forwarding Agent 2.8 Batch-Based Real-Time Agents Data Protection Enabling Agents in MediationZone You can use two different agents for data protection in MediationZone; Data Masking and Encryption. Data Masking Agent MediationZone offers data masking capabilities through its Data Masking agent, ensuring that sensitive personal data is protected in compliance with data protection regulations. With this agent you can both mask and unmask specific fields within User Data Records (UDRs), providing flexibility for batch and real-time data processing workflows. Key Features: Masking Methods : Profile-based approach, providing you with a selection of specific methods for masking; Crypto, Database, or Hash. Each method is tailored to different operational needs and compliance requirements. Supported databases for the Database masking method include Oracle, Postgres, and SAP HANA. Encryption and Decryption : Strong encryption and decryption capabilities using AES-128 and AES-256 standards. Key Management : Secure management of encryption keys through a JCEKS keystore. Data Transformation : Ability to transform input data into random data using SHA-256 hashing. Profile Management : Support for multiple profiles within the agent, enabling different configurations for various data handling requirements. Error Handling and Logging : Error handling and detailed logging mechanisms to track operations and troubleshoot issues. For more information on functionality and configuration, see the Data Masking Agent section in the MediationZone documentation. Encryption Agent MediationZone offers encryption capabilities through its Encryption agent. This functionality is crucial for protection of data in transit and at rest. Key Features: Encryption standards: Support for AES-128 and AES-256 encryption methods. Key management: Secure management of encryption keys through a JCEKS keystore or an external keystore. Data transformation: SHA-256 hashing to anonymise data. For more information on functionality and configuration, see the Encryption Agent section in the MediationZone documentation. Guidelines for DPP compliance in workflows MediationZone provides a suite of agents and profiles that enable you to store data temporarily or permanently. These can be used for integrating data protection standards into your workflows. Understanding how to leverage these agents efficiently is crucial for maintaining compliance. In the following sections, we describe the different agents and profiles that are typically used for storing data and guidelines for using them in a DPP context. Archiving Agent, Profile and Inspector Exapand to read more about guidelines for the Archiving agent, profile and inspector. Amazon S3 Forwarding Agent Expand to read more about guidelines for the Amazon S3 forwarding agent. Data Veracity Forwarding Agent Expand to read more about guidelines for the Data Veracity forwarding agent. Error Correction System Expand to read more about guidelines for the Error Correction System. SQL Forwarding & Processing Agents Expand to read more about guidelines for the SQL forwarding and processing agents. Disk Forwarding Agent Expand to read more about guidelines for the Disk forwarding agent. Database Forwarding Agent Expand to read about guidelines for the Database forwarding agent. Batch-Based Real-Time Agents Expand to read about guidelines for the batch-based real-time agents.

---

# Document 288: SAP CC Agent Preparations - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/391118898
**Categories:** chunks_index.json

The relevant jar files required for the preparations must be obtained from the SAP CC server provider. The Core SDK jar files can be found in SAP Convergent Charging Installation Materials. SAP CC Core SDK Jar Files for Version 2023 The following jar files are required by SAP CC agents when using with SAP Convergent Charging server version 2023: common_message.jar common_util.jar core_chargingplan.jar core_chargingprocess.jar core_client.jar jaxb-api-2.3.1.jar jaxb-core-2.3.0.1.jar jaxb-impl-2.3.8.jar logging.jar sap.com~tc~logging~java.jar Note! The version of SAP CC Core SDK client JAR files must match the version of your SAP CC core system (i.e. the back-end servers). From the unpacked SAP Convergent Charging installer, the jar files can typically be found by navigating to the directory and unzipping the core_sdk.zip file located in DATA_UNITS/<CC_VERSION>_TOOLS_CONTENT_UC_OSIND . Example - Unzip core_sdk.zip $ unzip DATA_UNITS/CC2023_TOOLS_CONTENT_UC_OSIND/core_sdk.zip -d core_sdk For the SAP Convergent Charging server patches, the JAR files can typically be found by unpacking the patch file for the SAP CC Core SDK software unit. Example - Unzip SAP CC Core SDK patch file $ unzip CORESDK02_0-80008788.ZIP -d core_sdk Example - Listing SAP CC Core SDK jar files $ ls -gG core_sdk/jars/ total 17152 -rw-r--r-- 1 174853 Feb 12 2024 common_message.jar -rw-r--r-- 1 660812 Feb 12 2024 common_util.jar -rw-r--r-- 1 691798 Feb 12 2024 core_chargingplan.jar -rw-r--r-- 1 426602 Feb 12 2024 core_chargingprocess.jar -rw-r--r-- 1 4917429 Feb 12 2024 core_client.jar -rw-r--r-- 1 128076 Feb 12 2024 jaxb-api-2.3.1.jar -rw-r--r-- 1 254858 Feb 12 2024 jaxb-core-2.3.0.1.jar -rw-r--r-- 1 1117712 Feb 12 2024 jaxb-impl-2.3.8.jar -rw-r--r-- 1 89161 Feb 12 2024 logging.jar -rw-r--r-- 1 302450 Feb 12 2024 sap.com~tc~logging~java.jar The classpaths for the jar files are specified for each EC. In the example below, the SAP jar files are located in MZ_HOME/3pp. Note! Ensure that you include existing paths, so that they are not overwritten. Example command to get existing classpaths: $ mzsh topo get topo://container:<container>/pico:<ec>/obj:config.classpath Example - Setting classpath $ mzsh topo set topo://container:<container>/pico:<ec name>/obj:config.classpath.jars ' ["lib/picostart.jar", "3pp/common_message.jar", "3pp/common_util.jar", "3pp/core_chargingplan.jar", "3pp/core_chargingprocess.jar", "3pp/core_client.jar", "3pp/jaxb-api-2.3.1.jar", "3pp/jaxb-core-2.3.0.1.jar", "3pp/jaxb-impl-2.3.8.jar", "3pp/logging.jar", "3pp/sap.com~tc~logging~java.jar"]' After the classpath has been set, you need to manually distribute the jar files so that they are in place when the EC is started. You can then restart the EC to register the changes in the configuration above for the SAP CC agents. Secure Communications via TLS The agent can be configured for secure communication via TLS. This requires a keystore be created for each EC host. For more information about setting up secure communication, refer to SAP CC Secured Connection . For SAP CC Online Agent, it is required to add the hostname information of the SAP Convergent Charging Core server Dispatcher Instance(s). This information is needed by the execution content server . The IP address needs to be explicitly mentioned. Refer to the SAP CC Online Agent Configuration page.

---

# Document 289: REST HTTP Interface - Buckets - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204611833/REST+HTTP+Interface+-+Buckets
**Categories:** chunks_index.json

Provisioning is supported via a REST HTTP Interface which is implemented using the standard HTTP methods GET , PUT , POST and DELETE . The interface supports XML and JSON formats. The REST HTTP Interface runs on the EC Web Interface and is started when the EC process is started. Authentication is performed against the platform, if possible. If the platform is unreachable the user is authenticated against the locally defined user (configured in EC web interface properties). Retrieving Buckets To retrieve all buckets for a subscriber: Example Retrieving Buckets GET http://localhost:9090/PCC/Buckets/<subscriber key>/Bucket HTTP/1.0 Example output: { "Buckets": [ { "Product": 1001, "Counters": [ { "Usage": { "entry": [ { "key": 0, "value": 0 }, { "key": 1, "value": 0 }, { "key": 2, "value": 0 } ] } } ], "ID": "1", "StartTime": "2014-08-04 12:00:00", "StopTime": "2014-08-12 00:00:00" } ] } Return Codes No return codes will be sent. A list with 0 or more elements will be returned. Retrieving a Specific Bucket To retrieve a specific bucket with a certain ID: Example Retrieving a specific bucket GET http://localhost:9090/PCC/Buckets/<subscriber key>/Bucket/<id> HTTP/1.0 Example output: { "Product": 1001, "Counters": [ { "Usage": { "entry": [ { "key": 0, "value": 0 }, { "key": 1, "value": 0 }, { "key": 2, "value": 0 } ] } } ], "ID": "1", "StartTime": "2014-08-04 12:00:00", "StopTime": "2014-08-12 00:00:00" } Return Codes Code Description Code Description 200 Will be returned if the bucket was successfully retrieved. 204 Will be returned if the bucket did not exist. 500 Will be returned if a server error occurred. Creating a Bucket To create a bucket: Example Creating a bucket using xml POST http://localhost:9090/PCC/Buckets/<subscriber key>/Bucket Bucket HTTP/1.0 Content-Type: application/xml The xml-data should be structured as follows: <Bucket> <Counters> <Usage> <entry> <key>0</key> <value>100</value> </entry> <entry> <key>1</key> <value>200</value> </entry> <entry> <key>2</key> <value>300</value> </entry> </Usage> </Counters> <ID>1016</ID> <Misc> <entry> <key>mykey</key> <type>string</type> <value>myvalue</value> </entry> </Misc> <Product>1006</Product> <StartTime>2015-01-02 18:00:00</StartTime> </Bucket> Example Creating a bucket using JSON POST http://localhost:9090/PCC/Buckets/<subscriber key>/Bucket Bucket HTTP/1.0 Content-Type: application/json The json-data should be structured as follows: { "ID": "1016", "Misc": { "entry": [ { "key": "mykey", "type": "string", "value": "myvalue" } ] }, "StartTime": "2015-01-02 18:00:00", "Product": 1006, "Counters": [ { "Usage": { "entry": [ { "key": 0, "value": 100 }, { "key": 1, "value": 200 }, { "key": 2, "value": 300 } ] } } ] } Note! The subscriber is created if it does not exist when the command is called. Return Codes Code Description Code Description 201 Will be returned if the bucket was successfully created. 500 Will be returned if a server error occurred. Updating a Bucket Updates are made using PUT . Example Updating a bucket PUT http://localhost:9090/PCC/Buckets/<subscriber key>/Bucket/<id> HTTP/1.0 Return Codes Code Description Code Description 200 Will be returned if the bucket was successfully updated. 500 Will be returned if a server error occurred. Deleting a Bucket To delete a bucket: Example Deleting a bucket DELETE http://localhost:9090/PCC/Buckets/<subscriber key>/Bucket/<id> HTTP/1.0 Return Codes Code Description Code Description 200 Will be returned if the bucket was successfully deleted. 204 Will be returned if the bucket that was intended to be deleted did not exist. 500 Will be returned if a server error occurred. Retrieving All Sessions for a Subscriber To retrieve all sessions for a subscriber: Example Retrieving sessions GET http://localhost:9090/PCC/Buckets/<subscriber key>/Session HTTP/1.0 Example output: { "Sessions": [ { "ID": "gx;222;1000009", "Misc": { "entry": [ { "key": "origin_host", "type": "string", "value": "sim" }, { "key": "origin_realm", "type": "string", "value": "example.com" } ] }, "InstalledRules": [ { "Rules": [], "QoS": 0 } ], "Reservations": [ { "Granted": { "entry": [ { "key": 1, "value": 1 } ] }, "Products": [ 2 ], "Misc": { "entry": [] } } ], "LastActive": "2015-10-30 11:02:55" } ] } Return Codes No return codes will be sent. A list with 0 or more elements will be returned. Deleting a Subscriber To delete a subscriber: Example Deleting a subscriber DELETE http://localhost:9090/PCC/Buckets/<subscriber key> HTTP/1.0 Note! Deleting a subscriber means deleting the whole object found at: http://localhost:9090/PCC/Buckets/<subscriber key> Any Buckets and Subscribers belonging to this <subscriber key>-object will get deleted as well. Return Codes Code Description Code Description 200 Will be returned if the subscriber was successfully deleted. 204 Will be returned if the subscriber that was intended to be deleted did not exist. 500 Will be returned if a server error occurred. Retrieving Information about a Subscriber To retrieve information about a subscriber: Example Retrieving information about a subscriber GET http://localhost:9090/PCC/Buckets/<subscriber key>/Subscriber HTTP/1.0 Example output: { "Groups": [ "Group1" ], "IsChanged": false, "SentNotifications": [2], "Misc": { "entry": [ { "key": "billing_system", "type": "string", "value": "test" } ] }, "Notifications": [1] } Return Codes Code Description Code Description 200 Will be returned if the information about the subscriber was successfully retrieved. 204 Will be returned if the subscriber did not exist. 500 Will be returned if a server error occurred. Updating a Subscriber To update a subscriber: Example Updating a subscriber PUT http://localhost:9090/PCC/Buckets/<id>/Subscriber HTTP/1.0 Return Codes Code Description Code Description 200 Will be returned if the subscriber was successfully updated. 50 Will be returned if a server error occurred. Error Codes There are several different codes that can be returned for the different operations. When creating a UDR: Error code Description Error code Description 201 Will be returned if the UDR was created. 409 Will be returned if a UDR with the stated key already exists, or if there are dependencies missing. 415 Will be returned if the UDR key is of type string and the key is missing, or if the key type is incorrect. 500 Will be returned if the UDR requires references that are missing, or if there was an error. When retrieving one UDR: Error code Description Error code Description 200 Will be returned if the requested UDR was found. 204 Will be returned if there are no UDR with the stated id. 500 If there was an error. When retrieving all UDRs: Error code Description Error code Description 200 Will be returned with an empty list or with a list containing the UDRs. When updating a UDR: Error code Description Error code Description 200 Will be returned if the UDR was updated successfully. 408 Will be returned if the keys in the URL and the XML are different, or the key in the URL is set to "0". 409 Will be returned if the UDR requires references that are missing. 500 Will be returned if there was an error. When deleting a UDR: Error code Description Error code Description 200 Will be returned if the UDR was deleted successfully. 204 Will be returned if there are no UDR with the stated key. 409 Will be returned if the UDR is referenced by another UDR. 500 Will be returned if there was an error.

---

# Document 290: mzcli - topo - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/547980340/mzcli+-+topo
**Categories:** chunks_index.json



---
**End of Part 13** - Continue to next part for more content.
