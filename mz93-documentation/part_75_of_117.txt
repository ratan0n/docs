# RATANON/MZ93-DOCUMENTATION - Part 75/112

---
**Dataset:** ratanon/mz93-documentation
**Part:** 75 of 112
**GitHub:** https://github.com/ratan0n/docs/tree/main/mz93-documentation
**Size:** ~65.3 KB
---

The UDRs in PCC.Buckets store usage related data for each subscriber. Use the APL function pccBucketDataLookup (see the section pccBucketDataLookup in APL - PCC BucketData Support - Buckets ) to get a BucketDataHolder from the database and the APL function pccBucketDataStore (see the section pccBucketDataStore in APL - PCC BucketData Support - Buckets ) to store a BucketDataHolder in the database. See APL - PCC BucketData Support - Buckets for further information about how to use the PCC.Buckets UDRs with APL and REST HTTP Interface - Buckets for information on how to access the PCC.Buckets UDRs from the REST HTTP interface. From the BucketDataHolder all usage related data for a subscriber is accessible via the following objects in the data model: Object Description Object Description Buckets Stores the actual usage information and statistics. There can be multiple buckets and multiple types of information counted. When a recurring usage counter is reset, its previous values can be kept for future processing. Sessions Stores session related data. No additional data to uphold a session should be needed, that is, do not rely on workflow memory to hold any session information. Subscriber Stores meta data about the subscriber necessary for usage counting. The amount of data should be kept to a minimum and only hold data to reduce the number of times an external subscriber database needs to be queried. Overview of the BucketDataHolder Data Model The different UDRs within the BucketDataHolder Data Model are connected as follows: Open Overview of the BucketDataHolder Data Model BucketDataHolder UDR The BucketDataHolder UDR holds information about all usage related data for a subscriber. Field Description Field Description Subscriber (Subscriber(PCC.Buckets.Subscriber)) > Holds the subscriber meta data necessary for usage counting, see the section below, Subscriber UDR. Buckets (list<PCC.Buckets.Bucket>) The list of buckets associated with the subscriber, see the section below Bucket UDR. Sessions (list<PCC.Buckets.Session>) The session list associated with the subscriber, see the section below Session UDR. Below is a screenshot of the UDR Assistance displaying the BucketDataHolder UDR: Open BucketDataHolder UDR Example - BucketDataHolder UDR The following values: Subscriber=Udr('PCC.Buckets.Subscriber', IsChanged=False, Notifications=[700,702,703], SentNotifications=None)) Buckets=Udr('PCC.Buckets.Buckets', Counters=[Udr('PCC.Buckets.Counter', Usage={0: 100,1: 200,2: 300})], ID='1', Product=100, StartTime='2011-10-01 00:00:00', StopTime=2011-10-30 18:00:00), ('PCC.Buckets.Buckets', Counters=[Udr('PCC.Buckets.Counter', Usage={0: 20,1: 100,2: 120})], ID='3', Product=120, StartTime='2011-10-01 00:00:00', StopTime=2011-11-01 00:00:00) Sessions=Udr('PCC.Buckets.Session', Destination='127.0.0.1', ID='ggsn1.operator.se;555111', InstalledRules=[1,2], LastActive='2011-10-24 10:34:42', Protocol='Gx', Reservations=[Udr('PCCBuckets.Reservation', Granted=500000, Product=100], Workflow='PCC.Multibucket.workflow_1') Subscriber=Udr('PCC.Buckets.Subscriber', IsChanged=True, Notifications=[700,703], SentNotifications=None)) Buckets=('PCC.Buckets.Buckets', Counters=[Udr('PCC.Buckets.Counter', Usage={0: 50,1: 300,2: 350})], ID='2', Product=110, StartTime='2011-10-01 18:00:00', StopTime=2011-11-01 00:00:00) Sessions=Udr('PCC.Buckets.Session', Destination='127.0.0.1', ID='ggsn2.operator.se;555222', InstalledRules=[3], LastActive='2011-10-25 16:12:53', Protocol='Gy', Reservations=[Udr('PCCBuckets.Reservation', Granted=250000, Product=110], Workflow='PCC.Multibucket.workflow_2') will give the following setup: The subscriber for the first bucket data holder will receive notifications 700, 702 and 703, while the subscriber for the second bucket data holder will receive notifications 700 and 703. The subscriber for the first bucket data holder has two buckets, 1 and 3, where the usage is counted for product 100. The subscriber for the second bucket data holder has one bucket, 2, where the usage is counted for product 110. The subscriber for the first bucket data holder had a session with ID ggsn1.operator.se;555111 open towards IP-address 127.0.0.1 where the installed rules with IDs 1 and 2 was applied, the protocol Gx was used, and a reservation of 500.000 bytes of data for product 100 was granted. The last request for the session was received on the 24th of October, 2011, at 10:34:42. The subscriber for the second bucket data holder had a session with ID ggsn2.operator.se;55522 open towards IP-address 127.0.0.1 where the installed rule with ID 3 was applied, the protocol Gy was used, and a reservation of 250.000 bytes of data for product 110 was granted. The last request for the session was received on the 25th of October, 2011, at 16:12:53. Subscriber UDR The Subscriber UDR holds the subscriber meta data necessary for usage counting, such as information if the subscriber information has been updated, the different notifications a subscriber should receive, etc. Field Description Field Description Groups (list<string>) Indicates the group(s) that the subscriber belongs to. IsChanged (boolean) Indicates whether bucket structure needs to be updated from an external source. Notifications (list<int>) The notifications that the subscriber should receive, see Notification UDR in Product Data Model . SentNotifications (list<int>) The notifications that has been sent to the subscriber. Misc (map<string, any>) See Misc Field for more information. Below is a screenshot of the UDR Assistance displaying the Subscriber UDR: Open Subscriber UDR Example - Subscriber UDR The following values: IsChanged=true Notifications=[700,702,703] IsChanged=false Notifications=[703] will give the following setup: The data for the first subscriber has been updated externally, and the bucket structure needs to be updated accordingly. The data for the second subscriber has not been updated. The first subscriber will receive notifications 700, 702 and 703, while the second subscriber will only receive notification 703. Both subscribers will also receive any notifications that has been set to be Required, see Notification UDR in Product Data Model . Bucket UDR The Bucket UDR stores the actual usage information and statistics. Each bucket references one product and has a start time and stop time that determines when the bucket should be activated and expire. Each bucket also contains one or several counters which are depending on the configuration for the selected product. Field Description Field Description ID (string) The ID of the bucket. The ID must be unique within the bucket list, and is used to identify a particular bucket both in the BucketDataHolder UDR, and from the REST HTTP interface. Product (int) References a product using its identifier. Each bucket must be associated with a product. The product has information that controls the behavior of the bucket. StartTime (date) The date and time when the bucket is to be activated, or when the last reset was done, depending on if the date is in the future or in the past. StopTime (date) The date and time when the bucket expires. Counters (list<PCC.Buckets.Counter>) Holds a list of counters. Each counter in the list can count multiple items. The list can retain multiple counters depending on the product configuration. Misc (map<string, any>) See Misc Field for more information. Below is a screenshot of the UDR Assistance displaying the Bucket UDR: Open Bucket UDR Example - Bucket UDR The following values: ID=1 Product=[100] StartTime='2011-10-01 00:00:00' StopTime='2011-10-30 18:00:00' Counters=[Udr('PCC.Buckets.Counter', Usage={0: 100, 1: 200, 2:300})] ID=2 Product=[110] StartTime='2011-10-01 18:00:00' StopTime='2011-11-01 00:00:00' Counters=[Udr('PCC.Buckets.Counter', Usage={0: 50, 1: 300, 2:350})] ID=3 Product=[120] StartTime='2011-10-01 00:00:00' StopTime='2011-11-01 00:00:00' Counters=[Udr('PCC.Buckets.Counter', Usage={0: 20, 1: 100, 2:120})] will give the following setup: The IDs for the three buckets; 1, 2 and 3, are used in the BucketDataHolder UDR for determining which buckets usage should be counted in. All of the buckets will start on the 1st of October and expire by the end of the 30th October, but at different times of the day. The counters for the first bucket has counted 100 bytes in output, 200 bytes in input and 300 bytes in total. The counters for the second bucket has counted 50 bytes in output, 300 bytes in input and 350 bytes in total. The counters for the third bucket has counted 20 bytes in output, 100 bytes in input and 120 bytes in total. Counter UDR The Counter UDR counts usage. Each counter can count multiple items. Field Description Field Description Usage (map<byte, long>) Records usage counts for multiple items; 0 - Input, 1 - Output, 2 - Total, 3 - Other. Below is a screenshot of the UDR Assistance displaying the Counter UDR: Open Counter UDR Example - Counter UDR The following values when counting usage in bytes: Usage={0: 100, 1: 200, 2: 300} Usage={0: 50, 1: 300, 2:350} Usage={0: 20, 1: 100, 2:120} will give the following setup: The first counter has counted 100 bytes in input, 200 bytes in output and 300 bytes in total. The second counter has counted 50 byte in input, 300 bytes in output and 350 bytes in total The third counter has counted 20 bytes in input, 100 bytes in output and 120 bytes in total. Session UDR The Session UDR stores data related to Diameter sessions, which includes information about the rules that applies, the workflow that is responsible for the session, any reservations made, when the session was last active, the session destination and the protocol used for the session. Field Description Field Description ID (string) The ID of the session. This ID must be unique within the session list. Usually a Diameter session id is used as the id. InstalledRules (list<InstalledRule>) Records the rules installed by this session, if any. Reservations (list<Reservation>) Records the reservations made by this session, if any. LastActive (date) The date and time when the session was last active. Workflow (string) Holds the name of the workflow responsible for this session. Destination (string) The destination for the session, for instance the Diameter destination host. Protocol (string) The protocol for this session, for instance Gx or Gy. Misc (map<string, any>) See Misc Field for more information. Below is a screenshot of the UDR Assistance displaying the Session UDR: Open S ession UD R Example - Session UDR The following values: ID=ggsn1.operator.se;555111 InstalledRules=[1,2] Reservations=[Udr('PCCBuckets.Reservation', Granted=500000,Product=100] LastActive='2011-10-24 10:34:42' Workflow='PCC.Multibucket.workflow_1' Destination='127.0.0.1' Protocol='Gx' ID=ggsn2.operator.se;555222 InstalledRules=[3] Reservations=[Udr('PCCBuckets.Reservation', Granted=25000,Product=110] LastActive='2011-10-25 16:12:53' Workflow='PCC.Multibucket.workflow_2' Destination='127.0.0.1' Protocol='Gy' will give the following setup: The IDs for the two sessions; ggsn1.operator.se;555111 and ggsn2.operator.se;55522 are used in the BucketDataHolder UDR for mapping the sessions to their respective subscribers. The first session uses rules 1 and 2, while the second session uses rule 3. The first session uses has a reservation of 500.000 bytes for product 100 and the second session has a reservation of 250.000 bytes for product 110. The first session was last active on the 24th of October, 10.34.42, while the second session was last active on the 25th of October, 16:12:53. The workflow instance PCC.MultiBucket.workflow_1 is responsible for the first session, and the workflow instance PCC.MultiBucket.workflow_2 is responsible for the second session. Both sessions have 127.0.0.1 as destinations. The first session handles with Gx sessions, while the second session deals with Gy sessions. InstalledRule UDR The InstalledRule UDR contains rule settings used by the Session UDR. Each installed rule references one bearer as well as the rules and QoS levels installed for the bearer. Field Description Field Description Bearer (bytearray) The bearer on which this rule is installed. QoS (int) The QoS installed for the bearer. Rules (list<int>) The list of rules installed on the bearer. Misc (map<string, any>) See Misc Field for more information. Below is a screenshot of the UDR Assistance displaying the InstalledRule UDR: Open InstalledRule UDR Example - InstalledRule UDR The following values: Bearer=375 QoS=4 Rules=1,2 Bearer=532 QoS=2 Rules=3 will give the following setup: The rules in the first InstalledRules setting is installed on bearer 375 and the second InstalledRules setting is installed on bearer 532. The first InstalledRules setting uses QoS level 4, while the second InstalledRules setting uses QoS level 2. The first InstalledRules setting uses rules 1 and 2 and the second InstalledRules setting uses rule 3. Reservation UDR The Reservation UDR controls the amount of data granted for the used counter items, i e products and buckets. Field Description Field Description Granted (map<byte, long>) Holds the amount of data granted for the used counter items. Products (list<int>) Records the list of products, and indirectly the buckets, that the reservation refers to, if applicable. Misc (map<string, any>) See Misc Field for more information. Below is a screenshot of the UDR Assistance displaying the Reservation UDR: Open Reservation UDR Example - Reservation UDR The following values: Granted=500000 Products=[100] Granted=250000 Products=[110] will give the following setup: The first reservation grants product 100 500000 bytes of data. The second reservation grants product 110 250000 bytes of data.

---

# Document 1768: HTTP Encryption - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204647257/HTTP+Encryption
**Categories:** chunks_index.json

The HTTP communication can be protected using TLS (Transport Layer Security), resulting in communication via the HTTPS protocol. Once the properties for secure communication are configured, TLS will automatically be switched on for the Execution Context Web Interface and the Platform Web Interface. Crypto algorithms are in place in the system to ensure secure data communication. The default crypto algorithms used are AES. If you require to modify the default crypto algorithms, see Platform Properties . This section includes the following sections: HTTP Configuration Properties Configuring a Keystore HTTP Standard Setup

---

# Document 1769: HTTPD_Deprecated Agent UDR Type - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205685878/HTTPD_Deprecated+Agent+UDR+Type
**Categories:** chunks_index.json

The UDR type created in the HTTPD_Deprecated agent can be viewed in the UDR Internal Format Browser. Format The built-in HTTP format definition must be extended prior to usage of the HTTPD format. To extend the HTTP format: Open the Ultra Format Editor by clicking the New Configuration button in the upper left part of the Desktop window, and then selecting Ultra Format from the menu. Enter: internal MYHTTPD: extends_class ("com.digitalroute.wfc.http.HttpdUDR") { // Additional fields (if required). }; The following fields are included in the built-in HTTPD format: Additional fields may be entered. This is useful mainly for transportation of variable values to subsequent agents. Save your Ultra by clicking on the Save button and entering the name of the Ultra.

---

# Document 1770: FTPS Collection Agent Input/Output Data and MIM - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205033219/FTPS+Collection+Agent+Input+Output+Data+and+MIM
**Categories:** chunks_index.json

Input/Output Data The Input/Output data is the type of data an agent expects and delivers. The agent produces bytearray types. MIM For information about the MIM and a list of the general MIM parameters, see Administration and Management in Legacy Desktop . Publishes MIM Parameter Description File Retrieval Timestamp This MIM parameter contains a timestamp, indicating when the file transfer started. File Retrieval Timestamp is of the date type and is defined as a header MIM context type. Source Filename This MIM parameter contains the name of the currently processed file, as defined at the source. Source Filename is of the string type and is defined as a header MIM context type. Note! When collecting files from a VAX file system, the name of the source file contains both path and filename. Source Filenames This MIM parameter contains a list of file names of the files that are about to be collected from the current collection directory. Note! When the agent collects from multiple directories, the MIM value is cleared after collection of each directory. Then, the MIM value is updated with the listing of the next directory. Source Filenames is of the list <any> type and is defined as a header MIM context type. Note! When collecting files from a VAX file system, the name of the source file contains both path and filename. Source File Count This MIM parameter contains the number of files that were available to this instance for collection at startup. The value is static throughout the execution of the workflow, even if more files arrive during the execution. The new files are not collected until the next execution. Source File Count is of the long type and is defined as a global MIM context type. Source Files Left This parameter contains the number of source files that are yet to be collected. This is the number that appears in the Execution Manager in Running Workflows tab in the Backlog column. Source Files Left is of the long type and is defined as a header MIM context type. Source File Size This parameter provides the size of the file that is about to be read. The file is located on the server. Source File Size is of the long type and is defined as a header MIM context type. Source Host This MIM parameter contains the name of the host from which files are collected, as defined in the Source or Advanced tabs. Source Host is of the string type and is defined as a global MIM context type. Source Pathname This MIM parameter contains the path name, as defined in the Source tab. Source Pathname is of the string type and is defined as a global MIM context type. Source Username This MIM parameter contains the login user name, as defined in the Source tab. Source Username is of the string type and is defined as a global MIM context type. Accesses The agent does not itself access any MIM resources.

---

# Document 1771: Derby Preparations - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204996789
**Categories:** chunks_index.json

Derby is installed in the Platform Container. The setup is managed by MediationZone itself which means no extra preparations are needed once the general preparations are finished according to General Preparations Platform . Once the container is installed, that is, after you have performed the software installation described in Platform Software Installation , the database files belonging to Derby are placed in a directory called mzdb under MZ_HOME. Note! Since the Derby database runs within the same process as the Platform, the Platform requires more memory than when using Oracle.

---

# Document 1772: JWT Validation Result UDR - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/304515657/JWT+Validation+Result+UDR
**Categories:** chunks_index.json

The OAuth validateAndDecodeJwt APL plugin produce one type of UDR: JwtValidationResult. JwtValidationResult This UDR is used for describing a specific attachment. Field Description Field Description errorMessage (string) The error message returned when validation fails. It will be null if validation succeeds. claims (map<string, any>) The decoded payload data. OriginalData (bytearray) The original data in bytearray format.

---

# Document 1773: List Functions - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204612205/List+Functions
**Categories:** chunks_index.json

This section describes functions that are used to manage lists and their elements. Lists can be created to hold any type of data. The following functions for List described here are: 1 listAdd 2 listClear 3 listCreate 4 listCreateSync 5 listFindIndex 6 listGet 7 listInsert 8 listRemove 9 listSet 10 listSize 11 listSort listAdd Adds a new element to the end of an existing list. void listAdd ( list<type> list, any value ) Parameter Description Parameter Description list The name of the list value Value to add to the list. The value must be of the same type as the list is designed to accept. Returns Nothing Example - Using listAdd The following code leaves a list consisting of the two elements 7 and 5. list <int> myIntList = listCreate(int, 7); listAdd(myIntList, 5); listClear Removes all elements from a list. void listClear ( list<type> list ) Parameter Description Parameter Description list The list of elements to be removed Returns Nothing listCreate Creates a list of any type, and (optionally) populates it. list<type> listCreate ( type, element1, //Optional element2, //Optional ... ) Parameter Description Parameter Description type The type of the elements comprising the list element<n> The value of an element to be added to the list. Optional parameters: if none is entered, the list will be empty. Returns The list listCreateSync Creates a synchronized list of any type, and (optionally) populates it. This function may be useful for global lists in real time workflows, where the same list may be accessed from several threads at the same time. list<type> listCreateSync ( type, element1, //Optional element2, //Optional ... ) Parameter Description Parameter Description type The type of the elements comprising the list element<n> The value of an element to be added to the list. Optional parameters: if none is entered, the list will be empty. Returns The list listFindIndex Calculates the index of a requested list element. The condition is tried for each element in the list until there is a match or the end of the list is reached. int listFindIndex ( list<type> list, varSpec, Condition, int startIndex ) //Optional Parameter Description Parameter Description list The list to evaluate varSpec Variable specification. Defines a variable to hold the list data for the condition evaluation. Can be either a valid variable name in which case the variable type is the same as the list element type, or a type can be explicitly set on the variable in which case the list elements are cast to this type and then assigned to the variable. An incorrect type will cause a runtime ClassCastException . Condition Condition for matching an item in the list. startIndex (Optional) index to start to search the list on. If startIndex is not specified, the list is searched from the beginning. Returns The index of the first matching element. If no element matched the condition, -1 is returned. The first element in the list is indexed 0 (zero). Example - Using listFindIndex A list of integers containing the following elements [50, 2, 4, 152, 4] is searched for an element equal to 4: debug( listFindIndex( myList, i, i == 4 ) ); The output is 2, since it is the index number of the first element equal to 4 in the list. listGet Retrieves an element from a given position in the list. any listGet ( list<type> list, int index) The index must be in the range 0<=index<listSize(list) or the workflow will abort with a runtime error. Parameter Description Parameter Description list A list index Index of the element to retrieve Returns The value given at the defined index listInsert Inserts a value on a given position in a list. Note that this will NOT overwrite any existing values on the position, but only move the old element up a position. void listInsert ( list<type> list, int index, type value ) Parameter Description Parameter Description list A list index Where to insert the new value value The new value Returns Nothing Example - Using listInsert A list consists of the following elements: [2, 5, 72, 19] and the new value 127 is to be inserted on index position 2. This means the new indexes for the elements containing 72 and 19 are now 3 and 4 respectively: listInsert( mylist, 2, 127); myList now looks like this: [2, 5, 127, 72, 19] listRemove Removes an element from a list. void listRemove ( list<type> list, int index ) Parameter Description Parameter Description list A list index Index of the value to remove. The index must be in the range 0<=index<listSize ( list ) or the workflow will abort with a runtime error. Returns Nothing listSet Replaces an existing element in a list. void listSet ( list<type> list, int index, type value ) Parameter Description Parameter Description list A list index The position of the element to be replaced value The new value to replace the existing with Returns Nothing Example - Using listSet A list consists of the following elements: [2, 5, 72, 19] and the new value 127 should replace the value of the element on index position 2: listSet( mylist, 2, 127); myList now looks like this: [2, 5, 127, 19] listSize Gets the size of a list. int listSize ( list<type> list) Parameter Description Parameter Description list A list Returns The number of elements in the list listSort Sorts a list of any type. For UDR lists, sorting is based on a field in the UDR. For all lists except for UDR lists: void listSort ( list<type> list, order ) //Optional For UDR lists: void listSort ( list<UDRtype> UDRlist, string field, order, //Optional udrtype ) //Optional Parameter Description Parameter Description list A list UDRlist A list of UDRs field Name of the UDR field to sort on. This field may contain any primitive type except for any , bitset and ipaddress . order Sorting order (optional). Could be one of ascending (default) or descending . udrtype Parameter to determine UDR type if the list is declared to hold generic UDRs. In the following bullets, the first is generic and must have the udrtype specified. The second does not require the udrtype since the UDR type is known from the declaration. list <drudr> MyList ; list <MyUDRType> MyList ; If a type name is used and the UDR cannot be converted to this type this will be a runtime error. Returns Nothing Example - Using listSort list<MyUDRType> myList; // Assume we have added items to the list listSort( myList, SequenceNumber, descending );

---

# Document 1774: General Preparations Platform - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204604175
**Categories:** chunks_index.json

A UNIX user must be created to execute the installation and run the MediationZone instance. Preferably create the user mzadmin , which is referenced throughout this document. Important! The mzadmin user must have read/write permissions for all the directories stated in the Environment Variables. To avoid security risks, do not use the root user in place of the mzadmin user for the application. For security reasons, ensure that the read/write/execute permissions for $MZ_HOME directory and sub-folders are given only to authorized users or user groups to prevent unauthorized access to any of the system files. During the installation procedure, the default application user , mzadmin , is automatically created - note that this is not related to the OS user or the DB user. You cannot create or use other application users than this default user until after the installation is complete. MediationZone should always be administrated by users belonging to the access groups created in MediationZone. See Access Controller for more information on how to create users and access groups. The final part of the general preparations is to ensure that the necessary third party products are installed, which are the required Java version, the platform database to be used (Oracle, PostgreSQL, SAP HANA, or Derby) and any additional software required by various parts of the system. See System Requirements for more information. This section includes the following subsections: Setting Environment Variables for Platform Preparing the Installer File for Platform Updating the Installation Properties for Platform Extracting Files for Platform

---

# Document 1775: System Upgrade - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204645418/System+Upgrade
**Categories:** chunks_index.json

In this scenario, MediationZone needs to be upgraded. Open Chain of events: One of the MediationZone systems is designated master and is updated with the most recent versions of all the configurations, typically by importing a fresh export made from the production system. The master MediationZone is upgraded by following the upgrade instructions in the Installation Instructions. When the system has been upgraded successfully, the configurations are exported to the local working copy using the vcexport command. The resulting XML files are compared with the ones in the Version Control System. Any changes to the files will be the result of a configuration upgrade or changes triggered by the upgrade. The new exported configurations are checked into the Version Control System. The rest of the MediationZone systems are upgraded. The latest versions of the configurations are checked out from the Version Control System and imported into the MediationZone systems.

---

# Document 1776: SMPP Agents Configuration - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205002027/SMPP+Agents+Configuration
**Categories:** chunks_index.json

To open the SMPP agents' configuration, click Build  New Configuration . Select Workflow from the Configurations dialog. When prompted to Select workflow type , select Realtime . Click Add agent and select either SMPP_Receiver in the Collection tab, or SMPP_Transmitter in the Processing tab, in the Agent Selection dialog. Double-click the agent icon or right-click the icon and select Edit agent , to display the Agent Configuration dialog. Both agents' configuration dialogs contain three different tabs; SMSC , ESME , and Connection . Note! The screenshots in this page shows the SMPP_Receiver agent, but the SMPP_Transmitter agent has the exact same settings as well. SMSC Tab The SMSC tab contains configurations related to the SMSC to/from which the agent will send/receive data. Open SMSC tab Setting Description Setting Description Remote Host Enter the IP address or hostname of the SMSC with which the agent will communicate in this field. Remote Port Enter the port number on the SMSC with which the agent will communicate in this field. ESME Tab The ESME tab contains configurations related to the ESME application connected to the SMSC to/from which the agent will send/receive data. Open SMPP agent configuration - ESME tab Setting Description Setting Description System ID Enter the ID of the ESME system requesting to bind with the SMSC in this field. Password Enter the password used by the SMSC to authenticate the ESME in this field. System Type Enter the type of ESME system in this field, e g VMS (Voice Mail System), OTA (Over-The-Air Activation System), etc. Type of Number Enter the type of number (TON) used in the SME address in this field, e g International, National, Subscriber Number, etc. Numbering Plan Indicator Enter the numbering plan indicator (NPI) used in the SME address in this field, e g ISDN, Data, Internet, etc. Address Range Enter the range of SME addresses used by the ESME in this field. Note! For IP addresses, it is only possible to specify a single IP address. A range of IP addresses is not allowed. Connection Tab Open SMPP agent configuration - Connection tab Setting Description Setting Description Reconnect Attempts Enter the number of reconnect attempts you want to allow in case a connection goes down in this field. Note! If you use the default setting, 0, in this field, this will mean that the number of reconnect attempts will be infinite, i e maxint. Reconnect Interval Enter the time interval you want to pass before making a reconnect attempt in this field. Transaction Timer Enter the time interval allowed between an SMPP request and the corresponding SMPP response in this field. Enquire Link Timer Enter the time interval allowed between operations after which an SMPP entity should interrogate whether its peer still has an active session in this field. This setting determines how often the enquire_link operation should be sent. This timer may be active on either communicating SMPP entity (i.e. SMSC or ESME). Operations For the Transmitter agent, the following operation pairs are supported: bind_transmitter - bind_transmitter_resp unbind - unbind_resp submit_sm - submit_sm_resp enquire_link - enquire_link_resp For the Receiver agent, the following operation pairs are supported: bind_receiver - bind_receiver_resp unbind - unbind_resp deliver_sm - deliver_sm_resp enquire_link - enquire_link_resp Note! Only one request - response operation pair can be handled simultaneously, which means that a response must be sent for a pending request before the next request can be handled. Note! The bind and unbind operations only occur when starting/stopping the workflow.

---

# Document 1777: Real-Time Disk_Deprecated Collection Agent Configuration - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204644671/Real-Time+Disk_Deprecated+Collection+Agent+Configuration
**Categories:** chunks_index.json

To open the real-time Disk_Deprecated collection agent configuration, click Build  New Configuration . Select Workflow from the Configurations dialog. When prompted to Select workflow type , select Realtime . Click Add agent and select Disk Deprecated from the Agent Selection dialog. Double-click the agent icon or right-click the icon and select Edit agent , to display the Agent Configuration dialog. Disk_Deprecated Tab The Disk_Deprecated tab contains settings related to the placement and handling of the source files to be collected by the agent. Open Disk_Deprecated collection agent - Disk_Deprecated tab File Information Setting Description Setting Description Directory Enter the path of the source directory on the local file system of the EC, where the source files reside. The path can be absolute or relative to the $MZ_HOME environment variable. During processing of a file, it will be temporarily stored in a subdirectory under DR_TMP_DIR in the specified directory. Filename Enter an expression that matches the source files on the local file system. Regular expressions according to Java syntax applies. For further information, see: http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html Example. To match all filenames beginning with TTFILE , type: ready_TTFILE.* Note! Collecting a file while it is open for writing in another application may cause loss of data. For this reason, it is recommended that you rename files after moving them to the source directory. The renamed files should include a suffix or prefix that is also included in the Filename expression. Compression Select Gzip to decompress files before collection and insertion into the workflow. If the collected files are not compressed, select No Compression . Polling Interval (ms) Enter the interval, in milliseconds, at which the source directory is to be scanned for new files. File Reader Size The agent moves files to the temporary directory for processing in bulk. Enter the maximum number of files to be included in each bulk move operation. Read Size (b) Enter the buffer size to be used for for reading files. When a decoder is selected the agent produces FileSend UDRs that contain one decoded UDR. On the other hand, when a decoder is not selected, the FileSend UDRs contain bytearrays which are split according to the value of Read Size (b) . Note! For performance reasons, it is recommended to set this value to a multiple of 1024. No of Thread(s) Enter the number of worker threads that should be used for file collection. This field determines the number of files that the agent can process concurrently. You should typically set the number of threads to match the number of workflow threads. To ensure that the files are processed in timestamp order, set No of Thread(s) to 1 and also select the checkbox Sort Files . Sort Files Select this checkbox to sort the files that are moved to the temporary directory for processing. The files are sorted according to timestamp in ascending order. Due to multithreading, the files may not be processed in this order. Timeout Handling Timeout (ms) When the agent routes the first partial data set to the workflow, a timeout counter starts. The timeout counter is reset when the workflows acknowledge reception of the complete file. If the timeout counter is exceeded the collected file is either moved to a user-specified directory or After Collection strategy is applied. Enter the timeout value in milliseconds. Move Files on Timeout Select this checkbox to move timed out files to an automatically created subdirectory that you specify in the Directory setting. Note! When this checkbox is cleared and a timeout occurs, the After Collection strategy is applied. Path When Move Files on Timeout is selected, enter the target directory for files that are subject to timeout handling. After Collection Move/Rename Select this radio button to move the source files to the directory specified in the Destination field, after the collection. If you use the Prefix or Suffix fields, the file is renamed as well. Enter the path of the directory on the local file system of the EC into which the source files should be moved after collection. The path can be absolute or relative to the $MZ_HOME environment variable. Note! It is possible to move collected files from one file system to another, however it will have a negative impact on performance. Prefix/Suffix Enter the prefix and/or suffix to append to the beginning/end of the name of the source files, after the collection. These fields are available if you have selected Move or Rename . Note! If you have selected Rename , the source files are renamed in the current directory. Make sure not to assign a Prefix or Suffix that result in files names that match the regular expression in Filename , or the files will be collected over and over again. Search/Replace Note! To apply Search and Replace , select Move/ Rename . Search : Enter the part of the filename that you want to replace. Replace : Enter the replacement text. Search and Replace operate on entries in a way that is similar to the Unix sed utility. The identified filenames are modified and forwarded to subsequent agents in the workflow. This functionality enables you to perform advanced filename modifications as well: Use regular expression in the Search entry to specify the part of the filename to extract. Note! A regular expression that fails to match the original file name will abort the workflow. Enter Replace with characters and meta characters that define the pattern and content of the replacement text. Remove If this radio button is selected, the source files are removed from the source directory after collection. Decoder Tab The Decoder tab contains settings related to decoding of the collected data. Open Disk_Deprecated collection agent - Decoder tab Open Disk_Deprecated collection agent when MZ Tagged Format is selected - Decoder tab

---

# Document 1778: SQL Collection Agent Input/Output Data and MIM - Batch - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205034703/SQL+Collection+Agent+Input+Output+Data+and+MIM+-+Batch
**Categories:** chunks_index.json

Input/Output Data The Input/Output data is the type of data an agent expects and delivers. The agent produces the UDR type selected from the UDR Type . MIM For information about the MIM and a list of the general MIM parameters, see MIM . The agent does not publish nor access any MIM parameters.

---

# Document 1779: STR File Structure - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204678451/STR+File+Structure
**Categories:** chunks_index.json

This section describes the file structure of the master repository in STR, i e MZ_HOME/common/config/cell/default/master . Open STR structure - Master repository Files in the STR contains configurations that are represented in HOCON format. Example - Pico configuration in STR config { properties { ec { httpd { port=9090 } } } } template="mz.standard-ec" HOCON also supports a "flat" format that you can use with properties , a type of attribute that you can set to control the behavior of pico instances in the STR : config { properties { ec.httpd.port=9090 } } template="mz.standard-ec" client.conf The file client.conf contains custom default values for Desktop properties and JVM arguments. These values are set for all connected Desktop instances. You may override the default properties in the Desktop launcher. config { jvmargs { . . . } properties { . . . } } default.conf The file default.conf contains the installed default values for Desktop properties and JVM arguments. Though it is possible to edit this file, it is recommended that you add set custom default in in client.conf , since the contents may be overwritten by MediationZone at any time. config { jvmargs { . . . } properties { . . . } } cell.conf The file cell.conf contains properties that are common to the Platform and ECs. common { config { name=common } #properties } standard.conf The file standard.conf contains predefined service definitions that are required by the system. You can override the properties in this file by updating custom.conf . <service> { config { #properties... } start-after=[service1,...,service n] template="1/standard/basic" } templates/<template name space>/picos/<template name>.conf The files in the templates directory contains pico configuration templates. The subfolder mz contains preconfigured templates that should not be edited: standard-ec standard-platform standard (base template for all pico types) Note! The name of the parent directory, e g mz , indicates a namespace that you must use when you reference the template in a pico configuration. Though it is possible to edit these files, it is recommended that you add custom templates in separate files and subdirectories, since the contents in mz may be overwritten by MediationZone at any time. Example - Pico Configuration Template config { properties { ec { backlog { dir=${mz.home}"/tmp" } httpd { password="DR_DEFAULT_KEY-1D2E6A059AF8120841E62C87CFDB3FF4" port=9090 user=mzadmin } shutdown { time=60000 } } pico { bootstrapclass="com.digitalroute.wf.pico.ECHTTPD" type=ec } } } template="mz.standard" template-only=true type=ec <pico name>.conf Each pico configuration is stored in a separate file with the suffix .conf , e g platform.conf or ec1.conf . The configuration includes template references, classpaths, JVM arguments, and properties. When you change these attributes in a configuration, the corresponding pico instance must be restarted. Properties that are set in <pico name> .conf override properties in container.conf and cell.conf . A configuration may also include "settings" attributes. Unlike e g properties, this type of attribute may contain array values and changes do not require restart of pico instances. File contents: { template=<template name space>.<template file name> settings { state=enabled tags=[] } config { classpath { #classpaths... } jvmargs { #jvmargs... } properties { #properties... { pico #picos.. { groups { #groups... } } } } } You can set the attributes of the pico process directly and/or inherit the attributes of a template. Attributes that are set directly will override those that are inherited from a template. Example - Usage of Pico Configuration Template { template="example-ec" settings { pico.groups=[group1] state=enabled tags=[tag1,tag2] } config { properties { ec.httpd.port: 9090 } } } container.conf The file container.conf holds system properties and attributes that describe the container. Properties that are set in container.conf overrides properties in cell.conf . Example - Container configuration additional-addresses=[] address="10.46.50.82" common { #properties pico.rcp.server.host="" } disabled=false You can change the address attribute of the local container using the following command: $ mzsh topo register -u --address <IP address or hostname> If you want to prevent ECs from starting in a container, set the attribute disabled to true. The default value is false. $ mzsh topo set topo://container:<container>/val:disabled <true|false> If the pico instances that run in the container should connect to the system from different addresses than the container address, you should add these to additional-addresses . $ mzsh topo set topo://container:<container>/obj:additional-addresses  [`mzsh topo get --format data-only topo://container:<container>/pico:<pico>/val:  config.properties.pico.rcp.server.host`] Example - Setting additional addresses $ mzsh topo get --format data-only topo://container:main1/pico:ec1/val:  config.properties.pico.rcp.server.host "10.46.50.82" $ mzsh topo set topo://container:main1/obj:additional-addresses ["10.46.50.82"] As an alternative to adding additional addresses, you may set the platform property mz.pico.skip-registration-check . This allows the pico instances to connect from any address.

---

# Document 1780: ECS Maintenance System Task Configuration - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204607288/ECS+Maintenance+System+Task+Configuration
**Categories:** chunks_index.json

To open the ECS Maintenance system task configuration: Click Build and expand the System Task folder. Click the ECS_Maintenance task. In the SystemTask folder, click the ECS_Maintenance workflow to open a workflow containing the ECS Maintenance agent. Double-click the agent icon to open the configuration. Cleanup Tab ECS_Maintenance configuration dialog - Cleanup tab Setting Description Setting Description UDRs Select this checkbox to delete UDRs from the ECS when they are older than the number of days stated (maximum 999 days). The default setting is 7 days. Clear this checkbox to keep the UDRs until manually cleaned out via the ECS Inspector. Enter 0 (zero) to remove all UDRs in state Reprocessed whenever the cleanup task is run, with a minimum time interval of one hour. Batches Select this checkbox to delete batches from the ECS when they are older than the number of days stated (maximum 999 days). The default setting is 7 days. Clear this checkbox to keep the batches until manually cleaned out via the ECS Inspector. Enter 0 (zero) to remove all batches in state Reprocessed whenever the cleanup task is run, with a minimum time interval of one hour. Statistics Select this checkbox to delete statistical data from the ECS when it is older than the number of days stated (1 - 999 days). The default setting is 21 days. Clear this checkbox to keep the statistics in the system. There is no other way to remove the ECS statistics via the GUI. Report Tab Open ECS Maintenance configuration dialog - Report tab Setting Description Setting Description UDR Statistics Select this checkbox to create UDR Statistics report data. Batch Statistics Select this checkbox to create Batch Statistics report data. Email Enter an email address to the receiver of the report. For information about email addresses, see Access Controller .

---

# Document 1781: Configuring PCC Properties - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204736361/Configuring+PCC+Properties
**Categories:** chunks_index.json

The following steps are required in order for MediationZone to connect to MySQL Cluster: Copy the following files from located in the /[MYSQLDIR]/lib/mysql folder in [CZ], to the /usr/lib directory in each [EZ]: libndbclient.so private/libcrypto.so.3 private/libssl.so.3 and ensure the subdirectory in the path is retained. Once installed, the pcc.properties file, located in the $ MZ_HOME/etc folder in [EC] , needs to be edited to connect to the host and port of the Management Node. Configure the following properties: In order for the Execution Context to be able to locate the pcc.properties file, the Execution Context property mz.pcc.properties must be set in the STR: $ mzsh topo set topo://container:<container>/pico:<pico>/val:config.properties.mz.pcc.properties <path> Restart the ECs.

---

# Document 1782: HTTP Proxy Support - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204613057/HTTP+Proxy+Support
**Categories:** chunks_index.json

MediationZone can be configured to route outgoing HTTP traffic through an HTTP proxy. This is commonly required in networking environments where the execution context has limited access to the internet. Proxy configuration has to be performed on each Execution Context (EC) that is required to route HTTP traffic through a proxy. Proxy support is available for: HTTP APL functions HTTP Batch agent GCP agents HTTP/2 Client agent Salesforce Streaming agent Web Services agents This page has the following sub-sections: 1 Configuring Proxy Support 2 Authenticating the Proxy 3 Example Configuration Configuring Proxy Support Standard Java system properties are used to configure MediationZone to route HTTP traffic through an HTTP proxy. These properties must be configured at the Execution Context (EC) level for all execution contexts. Refer to proxy properties here: Execution Context Properties . It is often necessary to provide a list of destinations that should not be routed through the proxy. This list can be configured using the proxy property http.nonProxyHosts . Note that this property, despite the name, applies to both http and https traffic. Authenticating the Proxy MediationZone supports basic authentication to HTTP proxy. The username and password are configured using system properties. Refer to the proxy properties here: Execution Context Properties . Example Configuration Here is an example of how to configure the system properties to use an HTTP Proxy. Use the following command to edit the system properties. mzsh topo open ec1 config { classpath {} jvmargs { args=[] maxMetaspace=[ "-XX:MaxMetaspaceSize=196M" ] } properties { mz.webserver.xframeoptions=DENY pico.groups="" ec.backlog.dir="/Users/mzadmin/mz9/mz9HttpProxy/tmp" ec.webserver.port=9090 http.proxyHost=192.168.205.4 http.proxyPort=3128 https.proxyHost=192.168.205.4 https.proxyPort=3128 http.proxyUser=test http.proxyPassword=DR-4-D999C75BC7A3C4AF1B4DAA7F134EEED9 https.proxyUser=test https.proxyPassword=DR-4-D999C75BC7A3C4AF1B4DAA7F134EEED9 http.nonProxyHosts="localhost|*.foo.com" jdk.http.auth.proxying.disabledSchemes="" jdk.http.auth.tunneling.disabledSchemes="" } vendor-jvmargs { hp {} sun {} } }

---

# Document 1783: MSMQ Agent Preparations - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204739660/MSMQ+Agent+Preparations
**Categories:** chunks_index.json

This section contains information on agent preparations that you must consider before configuring the MSMQ agents. Follow the steps below before configuring an MSMQ agent. Copy the JAR file ( jintegra.jar ) required to each Execution Context (EC) that must run the workflow. Add the JAR file to the classpath for each of the ECs using the topo command. Example to add jintegra.jar to classpath mzsh topo set topo://container:main1/pico:platform/obj:config.classpath '{jintegra:["/Users/apps/lib/jintegra.jar"]}' mzsh topo set topo://container:main1/pico:ec1/obj:config.classpath '{jintegra:["/Users/apps/lib/jintegra.jar"]}' Loading

---

# Document 1784: Dynamic Functions - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204677915/Dynamic+Functions
**Categories:** chunks_index.json

Dynamic functions enable you to dynamically call an agent, a plug-in, or a generic APL function by name. The following Dynamic Functions described here are: dynamicCall The dynamicCall function calls a user defined APL function. any dynamicCall ( any handler , string functionName , list<any> arguments ) Parameter Description handler The handler that is returned by dynamicImport , dynamicPlugin or dynamicCompile . If the handler is set to null , the functions that are defined in the agent are used. functionName The name of the function to call arguments A list of arguments to pass to the called function. To call a function that requires no argument, use either null or an empty list. Returns Either the result of the executed function,or null , if the function returns void Example - Using dynamicCall to call an agent defined function consume { // // Dynamic Call to call an agent defined function // list<any> args = listCreate(any); dynamicCall(null, "testA", args); listAdd(args, "HelloWorld"); dynamicCall(null, "testB", args); listAdd(args, 21); int result = (int) dynamicCall(null, "testC", args); debug(result); } void testA() { debug("testA called"); } void testB(string b) { debug("testB("+b+") called"); } int testC(string b, int c) { debug("testC("+b+", "+c+") called"); return c*2; } Example - Using dynamicCall to call a plugin function any plugin; initialize { // // Initialize DTK plugin - Using ClassName // plugin = dynamicPlugin( "com.<product>.apl.MyPluginExecutor"); } consume { // // Dynamic Call to call a plugin function // list<any> arguments; listAdd(arguments, 1024); dynamicCall(plugin, "myPluginExposedFunction", arguments); } Example - Using dynamicCall to call an APL Code defined function any aplCode; initialize { // // Dynamic Import of generic APL Code // aplCode = dynamicImport("Default.helloworld"); } consume { // // Dynamic Call to call an APL Code defined function // list<any> arguments; listAdd(arguments, "HelloWorld"); dynamicCall(aplCode, "myHelloFunc", arguments); } Example - Using dynamicCall to call a dynamically compiled function any compiled; initialize { compiled = dynamicCompile(""" void testA() { debug("testA called"); } """); } consume { // // Call to a dynamically compiled function // dynamicCall(compiled, "testA", null); } dynamicCompile The dynamicCompile function dynamically compiles APL Code and returns a handler that is used together with dynamicCall . any dynamicCompile ( string aplCode ) Parameter Description aplCode The APL Code to be compiled Returns Handler to use together with dynamicCall Example - Using dynamicCompile any aplCode = dynamicCompile("string helloWorld() { return "Hello World!"; } debug("Compiled function returned "+dynamicCall(aplCode, "helloWorld")); dynamicImport The dynamicImport function imports generic APL Code. The command returns a handler that is used together with dynamicCall . Note! Use this function only during initialization of workflow. any dynamicImport ( string confName ) Parameter Description confName The configuration name of APL Code to import. Returns Handler to use together with dynamicCall . Example - Using dynamicImport any aplCode; initialize { // // Dynamic Import of generic APL Code // aplCode = dynamicImport("Default.helloworld"); } dynamicPlugin The dynamicPlugin function initializes a DTK APL plug-in. For further information, see APL Plugins in the Development Toolkit User's Guide . The command returns a handler that you use together with dynamicCall . Note! Use this function only during initialization of workflow. any dynamicPlugin ( string classOrFunctionName ) Parameter Description classOrFunctionName The name of plug-inclass implementing DRAPLExecutor , or a function name that is defined by the plug-in Returns A handler that you use together with dynamicCall Example - Using dynamicPlugin any plugin1; any plugin2; initialize { // // Initialize DTK plugin - Using ClassName // plugin1 = dynamicPlugin( "com.<product>.apl.MyPluginExecutor"); // // Initialize DTK plugin - Using exposed function name // plugin2 = dynamicPlugin("myPluginExposedFunction"); }

---

# Document 1785: Updating Launcher Services Settings - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204610366/Updating+Launcher+Services+Settings
**Categories:** chunks_index.json

To update the settings of a launcher service, click the cogwheel icon ( ) next to the name or right-click and then select Service Settings from the pop-up menu. Configuration Tab To update the name or URL of a launcher service, select the Properties tab. Open Service Settings - Configuration tab Security Tab The Security tab contains settings related to digital certificates that are required for a secure connection, via HTTPS, and the cryptographic key that is required when client authentication is enabled on the Platform. Open Service Settings - Security tab The first time that you establish a secure connection to a Platform, the Trusted Certificates field will be populated automatically . If the certificate from the Platform changes, you will be prompted to accept the new certificate. When client authentication is enabled, you must import a key in the Client Key field. You can import the key from a keystore file or you may copy the key from an existing instance in the Desktop Launcher. Importing Key from File Right-click on the Client Key field and select Import Key from File . Select the keystore file and then click OK . Enter the password at the prompt. Copy Key from Existing Instance or Launcher Service Right-click on the Client Key field and select Copy Key From Instance or Copy from Service. Select a name of an instance or launcher service from the sub-menu. For further information about security settings and how to enable client authentication, see Network Security .

---

# Document 1786: Remote Access to Containers - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204613074
**Categories:** chunks_index.json

Remote access to Execution Containers makes it possible to start and stop all pico instances from the Platform Container. When you install a new Execution Container, remote access is enabled by default. Follow the steps below to manually enable remote access: Login as mzadmin on the host where the Execution Container is installed. Make sure that that the SSH is installed on the container host and that the SSH daemon is enabled. Make sure that the container is registered in the STR: $ mzsh topo register Run mzsh topo setupremote. $ mzsh topo setupremote Validate the content of the container: $ mzsh topo get topo://container:<container>/obj:remote The following attributes and objects should be included: java-home ssh-address ssh-hostkeys ssh-port ssh-username For further information about the mzsh topo command, see topo .

---

# Document 1787: Repair Rules - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205652222/Repair+Rules
**Categories:** chunks_index.json

Repair rules is only applicable to UDR Data Veracity records and are utilized in Data Veracity as a way for storing any repair conditions and business logic used in updating erroneous UDR fields with new values. The repair job is executed from the Data Veracity Search UI from a successful Query Result. For information about executing a repair job you may refer to Search & Repair . Unsupported Data Type for Search Searching, filtering and repairing of UDRs with list and map data types are currently not supported by Data Veracity. The Repair Rules where repair rules could be created, viewed or deleted. It is accessed by selecting the Repair Rules option in the Data Veracity Dashboard. Info! You can also create repair rules in the Data Veracity Search UI, refer to Search & Repair for the steps to create. Open Example - Repair Rules table. Repair Rules Sort Order Sorting by Name column is based on Javas default sorting behavior for Strings(for example, sorting of alphabetical characters in Java is case sensitive). Creating a Repair Rule Repair rules can be created by clicking on the New button. Open Example - Creating a new repair rule To create a new Repair rule, follow the steps below: Select the Data Veracity profile and the UDR type. This will fix the scope of the repair rule to be used on records identified by the specified Data Veracity profile and UDR type. Click on the New Rule button. Select the UDR Field in the first combo box. Select the operation to be conducted in the second combo box. You can also check the APL check box to allow the include business logic in the form of APL codes into the rule itself. Editing a Repair Rule Repair rules can be edited by clicking on the Edit button. Open Example - Editing an existing repair rule When editing a rule: You cannot rename the rule. You cannot change the Data Veracity profile or the UDR type. You can modify any existing rules that are present in the Repair Rules section. You can add new rules to support the existing repair rules or an altogether new repair rule for a new field. Deleting a Repair Rule Repair rules can only be deleted from the Repair Rules UI. Deleting a repair rule here will remove it completely from Data Veracity. To delete a Repair Rule, follow the steps below: Select one or multiple rules and click the Delete button. Click Delete when prompted to confirm the deletion. Open Example - Deleting a repair rule

---

# Document 1788: Excel Agents UDR Types - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205033017/Excel+Agents+UDR+Types
**Categories:** chunks_index.json

ExcelCellUDR The ExcelCellUDR type is used to indicate the type of data the cells in a received Excel file contains. Info! ExcelCellUDR fields of Date type can be formatted to a certain date and time format by setting the ec.excel.dateformat property within the Execution Context. See Execution Context for more information about the property. Field Description type (string) This field is the type of data contained in a cell. value (any) This field contains the actual data value in the cell. ExcelSheetUDR The ExcelSheetUDR contains a map of all the data in the indicated Excel tab to be processed. Field Description data (map<int,map<string,ExcelCellUDR>>) This field contains a map of all the included ExcelCellUDR s. name (string) This field contains the name of the tab in the Excel file. ExcelUDR The ExcelUDR contains a list over all the ExcelSheetUDRs to be processed. Field Description ExcelSheetUDR (list<ExcelSheetUDR>) This field contains a list of the ExcelSheetUDRs to be processed. Loading

---

# Document 1789: Operators - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204612169/Operators
**Categories:** chunks_index.json

The following operators are valid in the APL language. Operator Description Example Operator Description Example Arithmetic operators: + Addition (numeric types) or string concatenation (if left operand is of string type). string1 = string2 + string3; NumFld = NumFld + 1; Arithmetic operators (only numeric types): - Subtraction NumFld = NumFld - 2; * Multiplication NumFld = NumFld * 3; / Division NumFld = NumFld / 4; % Modulus NumFld = NumFld % 10; Unary operators (only primitive integer types, cannot be a UDR field): ++ Increment NumFld++; //Increment after evaluation ++NumFld; //Increment before evaluation -- Decrement NumFld--; //Decrement after evaluation --NumFld; //Decrement before evaluation; Bit operators (only integer types): & Bitwise AND NumFld = NumFld & 1; | Bitwise OR NumFld = NumFld | 2; << Shift bits left NumFld = NumFld << 1; >> Shift bits right NumFld = NumFld >> 1; Boolean operators: == Equal to if (Fld1 == 1) != Not Equal to if (Fld1 != 4) && Logical AND if (Fld1 == 1 && Fld2 != 4) || Logical OR if (Fld1 == 1 || Fld2 != 4) <= Less than or equal to if (Fld1 <= 5) < Less than if (Fld1 < 5) >= Greater than or equal to if (Fld1 >= 5) > Greater than if (Fld1 > 5) ! Not if (! BoolFld) Type conversions for the arithmetic operators follow the Java standard. The && and || operators have the same precedence. Both operators have right fixity. For clarity and to avoid errors, it is generally recommended to override the precedence rules by using parentheses in expressions. Example - Operator precedence consume { boolean a = false; boolean b = false; boolean c = true; boolean x; // The following statement will be parsed as // false && (false || true) // and evaluate to false x = a && b || c; debug(x); // This will evaluate to true x = (a && b) || c; debug(x); } Java and APL may differ In some circumstances, APL and Java are handling numeric values differently. APL may be automatically expanded to avoid overflow, this applies also to constant expressions. Example 1: A statement like: long x=1000000000000; is ok in APL, but will not compile in Java. Example 2: An expression like: long x=1000000*1000000; works as expected in APL. But in Java, it would assign x to the value -727379968, due to overflow.

---

# Document 1790: Legacy Desktop User Interface - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205035631/Legacy+Desktop+User+Interface
**Categories:** chunks_index.json



---
**End of Part 75** - Continue to next part for more content.
