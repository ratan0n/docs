# RATANON/MZ93-DOCUMENTATION - Part 16/112

---
**Dataset:** ratanon/mz93-documentation
**Part:** 16 of 112
**GitHub:** https://github.com/ratan0n/docs/tree/main/mz93-documentation
**Size:** ~65.6 KB
---

The UDRs in PCC.Buckets store usage related data for each subscriber. Use the APL function pccBucketDataLookup (see the section pccBucketDataLookup in APL - PCC BucketData Support - Buckets ) to get a BucketDataHolder from the database and the APL function pccBucketDataStore (see the section pccBucketDataStore in APL - PCC BucketData Support - Buckets ) to store a BucketDataHolder in the database. See APL - PCC BucketData Support - Buckets for further information about how to use the PCC.Buckets UDRs with APL and REST HTTP Interface - Buckets for information on how to access the PCC.Buckets UDRs from the REST HTTP interface. From the BucketDataHolder all usage related data for a subscriber is accessible via the following objects in the data model: Object Description Object Description Buckets Stores the actual usage information and statistics. There can be multiple buckets and multiple types of information counted. When a recurring usage counter is reset, its previous values can be kept for future processing. Sessions Stores session related data. No additional data to uphold a session should be needed, that is, do not rely on workflow memory to hold any session information. Subscriber Stores meta data about the subscriber necessary for usage counting. The amount of data should be kept to a minimum and only hold data to reduce the number of times an external subscriber database needs to be queried. Overview of the BucketDataHolder Data Model The different UDRs within the BucketDataHolder Data Model are connected as follows: Open Overview of the BucketDataHolder Data Model BucketDataHolder UDR The BucketDataHolder UDR holds information about all usage related data for a subscriber. Field Description Field Description Subscriber (Subscriber(PCC.Buckets.Subscriber)) > Holds the subscriber meta data necessary for usage counting, see the section below, Subscriber UDR. Buckets (list<PCC.Buckets.Bucket>) The list of buckets associated with the subscriber, see the section below Bucket UDR. Sessions (list<PCC.Buckets.Session>) The session list associated with the subscriber, see the section below Session UDR. Below is a screenshot of the UDR Assistance displaying the BucketDataHolder UDR: Open BucketDataHolder UDR Example - BucketDataHolder UDR The following values: Subscriber=Udr('PCC.Buckets.Subscriber', IsChanged=False, Notifications=[700,702,703], SentNotifications=None)) Buckets=Udr('PCC.Buckets.Buckets', Counters=[Udr('PCC.Buckets.Counter', Usage={0: 100,1: 200,2: 300})], ID='1', Product=100, StartTime='2011-10-01 00:00:00', StopTime=2011-10-30 18:00:00), ('PCC.Buckets.Buckets', Counters=[Udr('PCC.Buckets.Counter', Usage={0: 20,1: 100,2: 120})], ID='3', Product=120, StartTime='2011-10-01 00:00:00', StopTime=2011-11-01 00:00:00) Sessions=Udr('PCC.Buckets.Session', Destination='127.0.0.1', ID='ggsn1.operator.se;555111', InstalledRules=[1,2], LastActive='2011-10-24 10:34:42', Protocol='Gx', Reservations=[Udr('PCCBuckets.Reservation', Granted=500000, Product=100], Workflow='PCC.Multibucket.workflow_1') Subscriber=Udr('PCC.Buckets.Subscriber', IsChanged=True, Notifications=[700,703], SentNotifications=None)) Buckets=('PCC.Buckets.Buckets', Counters=[Udr('PCC.Buckets.Counter', Usage={0: 50,1: 300,2: 350})], ID='2', Product=110, StartTime='2011-10-01 18:00:00', StopTime=2011-11-01 00:00:00) Sessions=Udr('PCC.Buckets.Session', Destination='127.0.0.1', ID='ggsn2.operator.se;555222', InstalledRules=[3], LastActive='2011-10-25 16:12:53', Protocol='Gy', Reservations=[Udr('PCCBuckets.Reservation', Granted=250000, Product=110], Workflow='PCC.Multibucket.workflow_2') will give the following setup: The subscriber for the first bucket data holder will receive notifications 700, 702 and 703, while the subscriber for the second bucket data holder will receive notifications 700 and 703. The subscriber for the first bucket data holder has two buckets, 1 and 3, where the usage is counted for product 100. The subscriber for the second bucket data holder has one bucket, 2, where the usage is counted for product 110. The subscriber for the first bucket data holder had a session with ID ggsn1.operator.se;555111 open towards IP-address 127.0.0.1 where the installed rules with IDs 1 and 2 was applied, the protocol Gx was used, and a reservation of 500.000 bytes of data for product 100 was granted. The last request for the session was received on the 24th of October, 2011, at 10:34:42. The subscriber for the second bucket data holder had a session with ID ggsn2.operator.se;55522 open towards IP-address 127.0.0.1 where the installed rule with ID 3 was applied, the protocol Gy was used, and a reservation of 250.000 bytes of data for product 110 was granted. The last request for the session was received on the 25th of October, 2011, at 16:12:53. Subscriber UDR The Subscriber UDR holds the subscriber meta data necessary for usage counting, such as information if the subscriber information has been updated, the different notifications a subscriber should receive, etc. Field Description Field Description Groups (list<string>) Indicates the group(s) that the subscriber belongs to. IsChanged (boolean) Indicates whether bucket structure needs to be updated from an external source. Notifications (list<int>) The notifications that the subscriber should receive, see Notification UDR in Product Data Model . SentNotifications (list<int>) The notifications that has been sent to the subscriber. Misc (map<string, any>) See Misc Field for more information. Below is a screenshot of the UDR Assistance displaying the Subscriber UDR: Open Subscriber UDR Example - Subscriber UDR The following values: IsChanged=true Notifications=[700,702,703] IsChanged=false Notifications=[703] will give the following setup: The data for the first subscriber has been updated externally, and the bucket structure needs to be updated accordingly. The data for the second subscriber has not been updated. The first subscriber will receive notifications 700, 702 and 703, while the second subscriber will only receive notification 703. Both subscribers will also receive any notifications that has been set to be Required, see Notification UDR in Product Data Model . Bucket UDR The Bucket UDR stores the actual usage information and statistics. Each bucket references one product and has a start time and stop time that determines when the bucket should be activated and expire. Each bucket also contains one or several counters which are depending on the configuration for the selected product. Field Description Field Description ID (string) The ID of the bucket. The ID must be unique within the bucket list, and is used to identify a particular bucket both in the BucketDataHolder UDR, and from the REST HTTP interface. Product (int) References a product using its identifier. Each bucket must be associated with a product. The product has information that controls the behavior of the bucket. StartTime (date) The date and time when the bucket is to be activated, or when the last reset was done, depending on if the date is in the future or in the past. StopTime (date) The date and time when the bucket expires. Counters (list<PCC.Buckets.Counter>) Holds a list of counters. Each counter in the list can count multiple items. The list can retain multiple counters depending on the product configuration. Misc (map<string, any>) See Misc Field for more information. Below is a screenshot of the UDR Assistance displaying the Bucket UDR: Open Bucket UDR Example - Bucket UDR The following values: ID=1 Product=[100] StartTime='2011-10-01 00:00:00' StopTime='2011-10-30 18:00:00' Counters=[Udr('PCC.Buckets.Counter', Usage={0: 100, 1: 200, 2:300})] ID=2 Product=[110] StartTime='2011-10-01 18:00:00' StopTime='2011-11-01 00:00:00' Counters=[Udr('PCC.Buckets.Counter', Usage={0: 50, 1: 300, 2:350})] ID=3 Product=[120] StartTime='2011-10-01 00:00:00' StopTime='2011-11-01 00:00:00' Counters=[Udr('PCC.Buckets.Counter', Usage={0: 20, 1: 100, 2:120})] will give the following setup: The IDs for the three buckets; 1, 2 and 3, are used in the BucketDataHolder UDR for determining which buckets usage should be counted in. All of the buckets will start on the 1st of October and expire by the end of the 30th October, but at different times of the day. The counters for the first bucket has counted 100 bytes in output, 200 bytes in input and 300 bytes in total. The counters for the second bucket has counted 50 bytes in output, 300 bytes in input and 350 bytes in total. The counters for the third bucket has counted 20 bytes in output, 100 bytes in input and 120 bytes in total. Counter UDR The Counter UDR counts usage. Each counter can count multiple items. Field Description Field Description Usage (map<byte, long>) Records usage counts for multiple items; 0 - Input, 1 - Output, 2 - Total, 3 - Other. Below is a screenshot of the UDR Assistance displaying the Counter UDR: Open Counter UDR Example - Counter UDR The following values when counting usage in bytes: Usage={0: 100, 1: 200, 2: 300} Usage={0: 50, 1: 300, 2:350} Usage={0: 20, 1: 100, 2:120} will give the following setup: The first counter has counted 100 bytes in input, 200 bytes in output and 300 bytes in total. The second counter has counted 50 byte in input, 300 bytes in output and 350 bytes in total The third counter has counted 20 bytes in input, 100 bytes in output and 120 bytes in total. Session UDR The Session UDR stores data related to Diameter sessions, which includes information about the rules that applies, the workflow that is responsible for the session, any reservations made, when the session was last active, the session destination and the protocol used for the session. Field Description Field Description ID (string) The ID of the session. This ID must be unique within the session list. Usually a Diameter session id is used as the id. InstalledRules (list<InstalledRule>) Records the rules installed by this session, if any. Reservations (list<Reservation>) Records the reservations made by this session, if any. LastActive (date) The date and time when the session was last active. Workflow (string) Holds the name of the workflow responsible for this session. Destination (string) The destination for the session, for instance the Diameter destination host. Protocol (string) The protocol for this session, for instance Gx or Gy. Misc (map<string, any>) See Misc Field for more information. Below is a screenshot of the UDR Assistance displaying the Session UDR: Open S ession UD R Example - Session UDR The following values: ID=ggsn1.operator.se;555111 InstalledRules=[1,2] Reservations=[Udr('PCCBuckets.Reservation', Granted=500000,Product=100] LastActive='2011-10-24 10:34:42' Workflow='PCC.Multibucket.workflow_1' Destination='127.0.0.1' Protocol='Gx' ID=ggsn2.operator.se;555222 InstalledRules=[3] Reservations=[Udr('PCCBuckets.Reservation', Granted=25000,Product=110] LastActive='2011-10-25 16:12:53' Workflow='PCC.Multibucket.workflow_2' Destination='127.0.0.1' Protocol='Gy' will give the following setup: The IDs for the two sessions; ggsn1.operator.se;555111 and ggsn2.operator.se;55522 are used in the BucketDataHolder UDR for mapping the sessions to their respective subscribers. The first session uses rules 1 and 2, while the second session uses rule 3. The first session uses has a reservation of 500.000 bytes for product 100 and the second session has a reservation of 250.000 bytes for product 110. The first session was last active on the 24th of October, 10.34.42, while the second session was last active on the 25th of October, 16:12:53. The workflow instance PCC.MultiBucket.workflow_1 is responsible for the first session, and the workflow instance PCC.MultiBucket.workflow_2 is responsible for the second session. Both sessions have 127.0.0.1 as destinations. The first session handles with Gx sessions, while the second session deals with Gy sessions. InstalledRule UDR The InstalledRule UDR contains rule settings used by the Session UDR. Each installed rule references one bearer as well as the rules and QoS levels installed for the bearer. Field Description Field Description Bearer (bytearray) The bearer on which this rule is installed. QoS (int) The QoS installed for the bearer. Rules (list<int>) The list of rules installed on the bearer. Misc (map<string, any>) See Misc Field for more information. Below is a screenshot of the UDR Assistance displaying the InstalledRule UDR: Open InstalledRule UDR Example - InstalledRule UDR The following values: Bearer=375 QoS=4 Rules=1,2 Bearer=532 QoS=2 Rules=3 will give the following setup: The rules in the first InstalledRules setting is installed on bearer 375 and the second InstalledRules setting is installed on bearer 532. The first InstalledRules setting uses QoS level 4, while the second InstalledRules setting uses QoS level 2. The first InstalledRules setting uses rules 1 and 2 and the second InstalledRules setting uses rule 3. Reservation UDR The Reservation UDR controls the amount of data granted for the used counter items, i e products and buckets. Field Description Field Description Granted (map<byte, long>) Holds the amount of data granted for the used counter items. Products (list<int>) Records the list of products, and indirectly the buckets, that the reservation refers to, if applicable. Misc (map<string, any>) See Misc Field for more information. Below is a screenshot of the UDR Assistance displaying the Reservation UDR: Open Reservation UDR Example - Reservation UDR The following values: Granted=500000 Products=[100] Granted=250000 Products=[110] will give the following setup: The first reservation grants product 100 500000 bytes of data. The second reservation grants product 110 250000 bytes of data.

---

# Document 318: PCC Rules - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204677251/PCC+Rules
**Categories:** chunks_index.json

Search this document: PCC Rules from MediationZone is a Policy and Charging Control solution for 3GPP and non-3GPP environments. The uptake of mobile data services is not compensating for voice revenue in the developed markets, which makes it increasingly important to make data services more profitable for the service providers. Effective policy control is the key for service providers that are looking to manage the explosive growth in data traffic in a profitable way. Ensuring reasonable usage and allocating bandwidth based on a combination of subscriber and service criteria is essential when constantly updated offerings reflecting new services and technologies are required. PCC Rules is an extension of the Platform and delivers the capability to manage and retrieve policy rules based on 3GPP and non-3GPP definitions. The PCC Rules package will act as a rule repository, with which external systems can interact over different protocols, where the business logic will drive the selection of policy rules to be enforced by the appropriate network elements. The business logic is implemented as a workflow using the APL functions that are described in this document. The PCC Rules package comes pre-packaged with a 3GPP Gx Policy Rule Schema, according to [Gx Ref]. With PCC Rules you can create and apply different rules regarding Quality of Service and usage for different subscribers based on subscription type, location, current usage, etc. PCC Rules enable you to configure your Policy Control and Charging solution, either in a Desktop or by applying the APL functions in a batch workflow and/or using the REST HTTP Interface. Working with PCC Rules encompasses three different areas; Defining and updating rules - Includes creating, updating, and removing rules, which is done either in the Desktop, by using APL functions, or through the REST web interface. Managing updates of rules in runtime - Includes ensuring that when rules are updated in runtime, the latest rules will always be returned on rules lookup, which is done in a workflow using the APL functions described in this document. Looking up rules in runtime - Includes looking up rules based on requests from the network in runtime, which is done in a workflow using the APL functions described in this document. Prerequisites The reader of this document should be familiar with: The HTTP protocol, https://httpwg.org/specs/ Terms and Acronyms This section contains glossaries for all terms and acronyms used throughout the PCC and MediationZone documentation. Term/Acronym Definition Term/Acronym Definition PCC Policy and Charging Control PCRF Policy and Charging Rules Function 3GPP 3rd Generation Partnership Project Chapters The following chapters and sections are included: Data Model for PCC Rules Provisioning of PCC Rules Runtime APL Support for PCC Rules

---

# Document 319: Workflow Group - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204670560/Workflow+Group
**Categories:** chunks_index.json

The workflow group configuration enables you to manage workflow groups. A workflow group can consist of one or several workflows, or Workflow Group members, which enables you to configure several workflows as a single entity. The group consists of several workflows, and/or workflow groups, each with a diverse setup of scheduling, load balance, and event notification. In this section you will find all the information you need to create, configure, and execute a workflow group. This section includes the following subsections: Creating a Workflow Group Configuration Managing a Workflow Group Suspend Execution Workflow Group States

---

# Document 320: Icon UDR - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204643673/Icon+UDR
**Categories:** chunks_index.json

The Icon UDR is used to create a Font Awesome icon. The icon name must match one from the Font Awesome library, which requires an internet connection. Alternatively, you can use the Line Awesome library, which is bundled in MediationZone and does not require internet access. To use Line Awesome, set the lineAwesome property to true and use the corresponding Line Awesome icon names, for example, la-ban instead of fa-ban . You can also stack two icons. The icon specified in the stackedIconName field will appear on top and be slightly larger than the one below. Open To create the stacked icon shown above, enter the following code: Icon clearSearchIcon = udrCreate(Icon); clearSearchIcon.iconName = "fa-magnifying-glass"; clearSearchIcon.iconStyle = clearSearchIcon.SOLID; clearSearchIcon.stackedIconName = "fa-ban"; clearSearchIcon.stackedIconStyle = clearSearchIcon.SOLID; clearSearchIcon.stackedIconColor = "tomato"; The following fields are included in the Icon UDR : Field Description Field Description attributes (map<string,string>) This field may contain extra attributes to be added. cssClasses (list<string>) This field may contain a list of extra values added to class attribute. This is typically used to style the component. Please read more on Bootstrap . iconColor (string) This field may contain a string of the color. It will be added in the style attribute. It must follow CSS Color style. iconName (string) This field must contain the icon name. It must be a Font Awesome icon name, for example, fa-magnifying-glass. iconStyle (string) This field may contain a string of the icon style. It must following Font Awesome. Some constants is added to help: SOLID , REGULAR , LIGHT , DUETONE and THIN Default is SOLID id (string) This field may contain the id of the component. stackedIconColor (string) This field may contain a string of the color for the stacked icon. It will be added in the style attribute. It must follow CSS Color style. stackedIconName (string) This field may contain the icon name for an icon placed on top of the regular icon. It must be a Font Awesome icon name, eg. fa-ban. stackedIconStyle (string) This field may contain a string of the icon style for the stacked icon. It must following Font Awesome. Some constants is added to help: SOLID , REGULAR , LIGHT , DUETONE and THIN Default is SOLID lineAwesome (boolean) Setting this property to true will make the Icon use the Line Awesome library instead of Font Awesome. The iconName must then use Line Awesome icon names instead of Font Awesome icon names. The same iconStyles (SOLID, REGULAR etc) can be used.

---

# Document 321: Disk Collection Agent Configuration  - Batch - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204672750
**Categories:** chunks_index.json

You open the Disk collection agent configuration dialog from a workflow configuration. To open the Disk collection agent configuration, click Build  New Configuration . Select Workflow from the Configurations dialog. When prompted to Select workflow type, select Batch . Click Add agent and select Disk from the Collection tab of the Agent Selection dialog. Part of the configuration may be done in the Filename Sequence or Sort Order service tab described in Workflow Template . Disk Tab The Disk tab contains settings related to the placement and handling of the source files to be collected by the agent. Open Disk collection agent configuration - Disk tab Setting Description Setting Description Collection Strategy If there is more than one collection strategy available in the system a Collection Strategy drop-down list will also be visible. For more information about the nature of the collection strategy, refer to Appendix 4 - Collection Strategies . Directory Enter the absolute pathname of the source directory on the local file system, where the source files reside. The pathname might also be given relative to the $MZ_HOME environment variable. Note! Even if a relative path is defined, for example, input , the value of MIM parameter Source Pathname (see the section, Publishes, in Disk Collection Agent Input/Output Data and MIM - Batch ) includes the whole absolute path; /$MZHOME/input . Include Subfolders Select this check box if you have subfolders in the source directory from which you want files to be collected. Note! Subfolders that are in the form of a link are not supported. If you select Enable Sort Order in the Sort Order tab, the sort order selected will also apply to subfolders. Filename Enter the name of the source files on the local file system. Regular expressions according to Java syntax applies. For further information, see http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html . Example To match all filenames beginning with TTFILE , type: TTFILE.* Compression Select the compression type of the source files. Determines if the agent will decompress the files before passing them on in the workflow. No Compression - agent does not decompress the files. This is the default setting. Gzip - agent decompresses the files using gzip. Move to Temporary Directory If enabled, the source files will be moved to the automatically created subdirectory DR_TMP_DIR in the source directory, prior to collection. This option supports safe collection of a source file reusing the same name. Append Suffix to Filename Enter the suffix that you want added to the file name prior to collecting it. Important! Before you execute your workflow, make sure that none of the file names in the collection directory include this suffix. Inactive Source Warning (hours) If the specified value is greater than zero, and if no file has been collected during the specified number of hours, the following message is logged: The source has been idle for more than <n> hours, the last inserted file is <file>. Move to If enabled, the source files will be moved from the source directory (or from the directory DR_TMP_DIR , if using Move to Temporary Directory ) to the directory specified in the Destination field, after the collection. If the Prefix or Suffix fields are set, the file will be renamed as well. Note! It is possible to move collected files from one file system to another however it causes negative impact on the performance. Also, the workflow will not be transaction safe, because of the nature of the copy plus delete functionality. If it is desired to move files between file systems it is strongly recommended to route the Disk collection agent directly to a Disk forwarding agent, configuring the output agent to store the files in the desired directory. Refer to Disk Forwarding Agent - Batch for information. This is because of the following reasons: It is not always possible to move collected files from one file system to another. Moving files between different file systems usually cause worse performance than having them on the same file system. The workflow will not be transaction safe, because of the nature of the copy plus delete functionality. Rename If enabled, the source files will be renamed after the collection, remaining in the source directory from which they were collected (or moved back from the directory DR_TMP_DIR , if using Move To Temporary Directory). Remove If enabled, the source files will be removed from the source directory (or from the directory DR_TMP_DIR, if using Move To Temporary Directory), after the collection. Ignore If enabled, the source files will remain in the source directory after collection. Destination Enter the absolute pathname of the directory on the local file system of the EC into which the source files will be moved after collection. The pathname might also be given relative to the $MZ_HOME environment variable. This field is only enabled if Move to is selected. Prefix/Suffix Enter the prefix and/or suffix that will be appended to the beginning respectively the end of the name of the source files, after the collection. These fields are only enabled if Move to or Rename is selected. Note! If Rename is enabled, the source files will be renamed in the current directory (source or DR_TMP_DIR ). Be sure not to assign a Prefix or Suffix, giving files new names, still matching the filename regular expression, or else the files will be collected over and over again. Search and Replace To apply Search and Replace , select either Move to or Rename . Search : Enter the part of the filename that you want to replace. Replace : Enter the replacement text. Search and Replace operate on your entries in a way that is similar to the Unix sed utility. The identified filenames are modified and forwarded to the following agent in the workflow. This functionality enables you to perform advanced filename modifications, as well: Use regular expression in the Search entry to specify the part of the filename that you want to extract. Note! A regular expression that fails to match the original file name will abort the workflow. Enter Replace with characters and meta characters that define the pattern and content of the replacement text. Search and Replace Examples To rename the file file1.new to file1.old , use: Search : .new Replace : .old To rename the file JAN2011_file to file_DONE , use: Search : ([A-Z]*[0-9]*)_([a-z]*) Replace : $2_DONE Keep (days) Enter the number of days to keep source files after the collection. In order to delete the source files, the workflow has to be executed (scheduled or manually) again, after the configured number of days. Note, a date tag is added to the filename, determining when the file may be removed. This field is only enabled if Move to or Rename is selected. Use File Reference Select this check box if you want to forward the data to an SQL Loader agent. See SQL Loader Agent for further information.

---

# Document 322: SAP CC Batch Agent Configuration - Real-Time - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204609100/SAP+CC+Batch+Agent+Configuration+-+Real-Time
**Categories:** chunks_index.json

You open the SAP CC Processing agent configuration dialog from a workflow configuration. To open the SAP CC Batch agent configuration, click Build  New Configuration . Select Workflow from the Configurations dialog. When prompted to Select workflow type , select Realtime . Click Add agent and select SAP CC Batch from the Processing tab of the Agent Selection dialog. Open SAP CC Batch agent configuration - Connection tab Setting Description Setting Description Hosts In this section, add the IP address/hostname and external charging port of at least one SAP Convergent Charging Core server Dispatcher Instance. Enable Authentication Select this check box to enable charging API authentication. Note! Charging API Authentication is only available for SAP CC version 4.1 SP2 and later. User Name SAP CC user id Password The password for the SAP CC user Timeout The timeout (in milliseconds) to apply for each connection Enable Secured Connection Select to use TLS encrypted communication with Hosts . For more information about setting up Secured Connection, refer to SAP CC Secured Connection . Keystore Path The path to the keystore on an Execution Container host. The path must be the same for all hosts. Note! The keystore format to be used by this particular agent is PKCS12 only. Keystore Password The password for the keystore Advanced Settings Tab The Advanced Settings tab contains extended configuration options for the agent. Open SAP CC Batch agent configuration - Advanced Settings Tab Setting Description Setting Description Enable Debug Events Select this check box to enable debug mode. This option is useful for testing purposes. Convert BigDecimal Response to String Select this check box to allow the conversion of the BigDecimal data type from the SAP Convergent Charging response into string. By default, the check box is empty. Note! In terms of backwards compatibility, enabling this option prevents any compatibility issues with workflows that support the configurations from before the BigDecimal data type was introduced in version 8.0.5.0.

---

# Document 323: Legacy KafkaExceptionUDR - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/301138706/Legacy+KafkaExceptionUDR
**Categories:** chunks_index.json

The KafkaExceptionUDR is used to return a message if an error occurs. Field Description Field Description message (string) This field provides a message with information on the error which has occurred.

---

# Document 324: REST Client_Deprecated UDR Types - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204642589
**Categories:** chunks_index.json

RESTCycleUDR The RESTCycleUDR type is used to pass data between the workflow and REST Client_Deprecated agent. Field Description Field Description Context (any) This field that can be used in the workflow configuration to keep track of, and use, internal workflow information related to a request from the REST Client_Deprecated agent. For instance, before you route a RestCycle UDR to the REST Client_Deprecated agent, store the TCPIPUDR from a TCP/IP collection agent in the Context field. You can then read the TCPIPUDR from the Context field in the RESTCycle UDR that contains the response from the REST Client_Deprecated agent, and use it to send back a response to the TCP/IP collection agent. Error (RESTError(RESTClient)) This field contains information related to internal processing errors. Request (RESTRequest(RESTClient)) This field contains the request from the REST Client_Deprecated agent to the server. RequestSentTime (long) This field contains the timestamp from before the REST request was sent. Response(RESTResponse(RESTClient)) This field contains the response from the server to the REST Client_Deprecated agent. ResponseReceivedTime (long) This field contains the timestamp from when the REST response was generated. SessionId (string) This field contains a string representation of a random UUID. The nested UDR types of RESTCycleUDR are described below. RESTRequest Field Description Field Description Body (bytearray) This field contains the HTTP message body. Header (map<string,string>) This field may contain an HTTP header. The header fields are stored as key-value pairs. The REST Client_Deprecated agent will override any values that you set in the Authorization field of the header. HeaderV2 (map<string,list<string>>) This field may contain an HTTP header. The header fields are stored as key-value pairs. The REST Client agent will override any values that you set in the Authorization field of the header. Note! If both Header and HeaderV2 are set, HeaderV2 will override Header . Method (string) This field must contain the HTTP method. The REST Client_Deprecated agent does not validate the specified method, and any string value is considered valid. Params (map<string,string>) This field may contain HTTP parameters that are passed in the query string. The parameters are stored as key-value pairs. ResourceURI (string) This field contains a resource URI, relative to the base URL that is configured in the REST Client_Deprecated agent. If the base URL does not end with slash character, you must include it in ResourceURI , e g "/search". Example - Creating a REST request in APL import ultra.RESTClient; consume { RESTCycleUDR aUDR = udrCreate(RESTCycleUDR); RESTRequest req = udrCreate(RESTRequest); //Create and set header map<string,string> header = mapCreate(string,string); mapSet(header,"Accept","*/*" ); req.Header = header; //Set HTTP method req.Method = "GET"; //Set resource URI req.ResourceURI="/get"; aUDR.Request = req; udrRoute(aUDR); } RESTResponse Field Description Field Description Body (bytearray) This field contains the HTTP message body. Header (map<string,string>) This field may contain an HTTP header. The header is stored as key-value pairs. HeaderV2 (map<string,list<string>>) This field may contain an HTTP header. The header is stored as key-value pairs. ResponseCode (int) This field contains the response code from the server. Example - Receiving a REST response in APL import ultra.RESTClient; consume { if (instanceOf(input,RESTCycleUDR)) { RESTResponse resp = udrCreate(RESTResponse); resp = ((RESTCycleUDR)input).Response; debug("Response Code:" + resp.ResponseCode); list<string> mKeys = mapKeys(resp.Header); for(string i:mKeys) { debug("Header:" + i + "=" + mapGet(resp.Header,i)); } debug(baToStr(resp.Body)); } } Note! HTTP redirect is currently not supported. When the response code is 301 (Moved Permanently) or 302 (Found), the REST Client_Deprecated agent will not follow the URL in the header. In order to handle redirects, you must check the ResponseCode field in the RESTResponse UDR. If the value is 301 or 302, you must configure the APL code to send a new request to the URL that is specified in the Location field of the header. Hint! When the body field contains a JSON formatted string, you can use the APL function jsonDecode to decode the contents. For further information about this function, see 21. JSON Functions in the APL Reference Guide . When the body field contains XML data, you can use the XML schema support in Ultra to decode the contents. For further information about XML and Ultra, see 18. XML Schema Support in the Ultra Reference Guide . RESTError Field Description Field Description ErrorCode (int) This field contains an internal error code: 0 - No error 1 - The response time from the remote server exceeded the timeout value of the agent. 2 - The number of outstanding requests exceeded the maximum value of the agent. 4 - Unable to refresh token. This error will be returned if the agent has tried to refresh the token 10 times without success. 5 - The response payload size exceeded limit. To resolve this error, you can configure the max content length through topo configuration. 99 - Miscellaneous error. ErrorMessage (string) This field contains a description of the error. Example - Handling errors APL import ultra.RESTClient; consume { if (instanceOf(input,RESTCycleUDR)) { if(((RESTCycleUDR)input).Error.ErrorCode!=0) { udrRoute((RESTCycleUDR)input,"RESTCycleUDR_error"); } else { //... } } } OAuth2UDR Field Description Field Description accessTokenURI (string) The URI where the access token can be obtained. bodyParams (map,<string,string>) Some authentication servers may require additional parameters in the body of the token requests, these go into this field in a map format. clientId (string) The unique client identifier issued by the authorization server. clientSecret (string) The client secret. grantType (string) The grant type; either client credentials or resource owner password credentials. overrideBaseURL (string) Determines whether the BaseURL may be overridden or not. password (string) The password associated with the username.This is mandatory when grant type is resource owner password credentials. username (string) The resource owner username, i e end-user granting access to a protected resource. This is mandatory when grant type is resource owner password credentials. If the REST Client_Deprecated agent consumes a new UDR, it will execute Authentication.

---

# Document 325: STR Replication - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205815937/STR+Replication
**Categories:** chunks_index.json

The Platform Container holds the authoritative version of the STR, any changes to the registry must be done in this copy. Each Execution Container has a replica of the STR. When a process is started on an Execution Container, or any other actions relying on the STR is performed, the Execution Container replicates any changes to the registry from the Platform Container. Changes to the STR replicas on individual containers are not possible, since they will be overwritten by the version residing on the Platform. Open STR Replication

---

# Document 326: Data Veracity Maintenance System Task Configuration - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205684804/Data+Veracity+Maintenance+System+Task+Configuration
**Categories:** chunks_index.json

To open the Data Veracity Maintenance system task configuration: Go to Build screen and select SystemTask folder from the Configurations Navigator . Open DataVeracity_Maintenance workflow in SystemTask Click the DataVeracity_Maintenance workflow. In the workflow, double-click the agent icon or select the agent icon and click the Edit button to open the agent configuration dialog. Pre Delete Any UDRs that has the state Pre_Delete will have to be approved for deletion by a user with the appropriate privileges and permissions. Pre_Delete UDRs will not be removed by the DataVeracity_Maintenance System Task workflow. Cleanup Tab Open Da taVera city_Maintenance configuration Setting Description Setting Description Reprocessed If this check box is selected, UDRs with the state Reprocessed will be deleted from all Data Veracity tables when they are older than the number of days stated (maximum 999 days). If disabled, the UDRs will remain until manually cleaned out via the Search option in the Data Veracity Web UI . If 0 (zero) is entered, all UDRs with state Reprocessed will be removed whenever the cleanup task is performed, with a minimum time interval of one hour. Default setting is 7 days. Delete_Approved If this check box is selected, UDRs with the state Delete_Approved will be deleted from all Data Veracity tables when they are older than the number of days stated (maximum 999 days). If disabled, the UDRs will remain until manually cleaned out via the Search option in the Data Veracity Web UI . If 0 (zero) is entered, all UDRs with state Delete_Approved will be removed whenever the cleanup task is performed, with a minimum time interval of one hour. Def ault set ting is 7 days.

---

# Document 327: APL - PCC BucketData Support - Buckets - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204743224/APL+-+PCC+BucketData+Support+-+Buckets
**Categories:** chunks_index.json

The BucketData APL functions are used for managing the storage of bucket data objects. The BucketData Support functions include: pccBeginBucketDataTransaction Creates a transaction object that can be called when using transaction lock. any pccBeginBucketDataTransaction() Parameters Parameter Description Returns: A transaction object. Example any myTransaction = pccBeginBucketDataTransaction (); will create a transaction object named myTransaction . pccBucketDataLookup Retrieves the BucketDataHolder object with the stated key from storage. BucketDataHolder pccBucketDataLookup( string key, any txn ) Parameters Parameter Description key The key that uniquely identifies the BucketDataHolder object. txn States the transaction object to be used when using transaction lock. If transaction lock is not used, this parameter should be set to null . Returns: The BucketDataHolder object, if it was found in the storage, otherwise null. Example pccBucketDataLookup ("555", myTransaction); will retrieve a BucketDataHolder object with key 555 from storage and apply transaction lock with the transaction object myTransaction . pccBucketDataLookupMany Retrieves a number of BucketDataHolder objects included in the stated list from storage. map<string, BucketDataHolder> pccBucketDataLookupMany ( list<string> keys, any txn ) Parameters Parameter Description keys The list of keys that uniquely identify the BucketDataHolder objects. txn States the transaction object to be used when using transaction lock. If transaction lock is not used, this parameter should be set to null . Returns: The BucketDataHolder objects, if they were found in the storage, otherwise an empty map. Example pccBucketDataLookupMany(myList, myTransaction); will retrieve the BucketDataHolder objects stated in the myList list from storage and apply transaction lock with the transaction object myTransaction . pccBucketDataStore Stores the BucketDataHolder object to storage. boolean pccBucketDataStore ( string key, BucketDataHolder bdh, any txn [, boolean throwException, int expiration] ) To avoid race conditions during the creation of a new bucket data holder object it is recommended to use a transaction object. If it is not used and there are two parallel requests for object creation, the second request will overwrite the first. Parameters Parameter Description key The key that uniquely identifies the BucketDataHolder object. bdh The BucketDataHolder object to store. txn States the transaction object to be used when using transaction lock. If a transaction without a lock is used, this parameter should be set to null . It is also important to commit (see pccCommitBucketDataTransaction) the transaction when txn is used. throwException An optional parameter that can be set to false to be able to handle any storage errors. In this case the return value has to be checked and the pccLastError* functions to get the actual error (see APL - PCC Provisioning Plugins - Buckets ). expiration An optional parameter that can be set to an integer value in seconds. This value is the TTL (Time-To-Live) for the BucketDataHolder object passed along with it. This parameter is only supported for Couchbase data store, versions 5.5 and above. Note! If you use the expiration parameter, it is mandatory to set five (5) parameters for the pccBucketDataStore function. If the expiration parameter is not set, TTL will be zero (0) per default / bucket default. Zero is interpreted as infinity. If only three or four parameters are supplied to the pccBucketDataStore function, TTL will be 0. If transaction ( txn ) is used, TTL start time will be from the time of transaction commit (pccCommitBucketDataTransaction). Returns: True if the operation succeeded. This will always be the case unless throwException is set to false . Example pccBucketDataStore("777", myBucket, myTransaction, true, 60); In the case of using a Couchbase data store, the above function stores the myBucket BucketDataHolder object with 60 seconds TTL and key 777 , while adding the BucketDataHolder object into the transaction object myTransaction . In the case of any other data store, the above function stores the myBucket BucketDataHolder object with key 777 , while adding the BucketDataHolder object into the transaction object myTransaction . pccCommitBucketDataTransaction Commits the changes that have been made to the BucketDataHolder objects that are using the stated transaction object. void pccCommitBucketDataTransaction( any txn ) Parameters Parameter Description txn The transaction object for which changes should be committed. Example pccCommitBucketDataTransaction (myTransaction); will commit the changes made to the BucketDataHolder objects using the myTransaction transaction object. pccRollbackBucketDataTransaction Removes any changes that have been made to the BucketDataHolder objects that are using the stated transaction object. void pccRollbackBucketDataTransaction( any txn ) Parameters Parameter Description txn The transaction object for which changes should be rolled back. Example pccRollbackBucketDataTransaction (myTransaction); will rollback the changes made to the BucketDataHolder objects using the myTransaction transaction object. pccBucketDataRemove Removes a BucketDataHolder object from storage. void pccBucketDataRemove( string key, any txn ) Parameters Parameter Description key The key that uniquely identifies the BucketDataHolder object. txn The transaction when transaction lock is used. Example pccBucketDataRemove ("754", myTransaction); will remove the BucketDataHolder object with key 754> from storage and apply transaction lock with the transaction object >myTransaction . pccCreateBucketDataKeyIterator Creates an iterator which is used for moving from key to key in the database. any pccCreateBucketDataKeyIterator( [string startKey [, string stopKey]] ) Parameters Parameter Description startKey Optional parameter for stating which key to start with. This key will also be included. stopKey Optional parameter for stating which key to end with. This key will also be included. Returns: The iterator that has been created. Example any myIterator = pccCreateBucketDataKeyIterator( ); will create an iterator named myIterator . pccDestroyBucketDataKeyIterator Removes the stated iterator and returns all the resources that are being used. void pccDestroyBucketDataKeyIterator( any iterator ) Parameters Parameter Description iterator The iterator you want to remove. Example pccDestroyBucketDataKeyIterator(myIterator); will remove the iterator named myIterator . pccHasNextBucketDataKey Asks the iterator if there are more keys to retrieve. boolean pccHasNextBucketDataKey( any iterator ) Parameters Parameter Description iterator The iterator you want to ask. Returns: Information whether there is more data to retrieve or not. If true is returned, there is more data to be retrieved with the pccGetNextBucketDataKey function. If false is returned, there is no more data and the function pccGetNextBucketDataKey should not be called again. Example pccDestroyBucketDataKeyIterator(myIterator); will return the next key from the iterator named myIterator if the iterator has next key. pccGetNextBucketDataKey Retrieves the next key from the iterator. string pccGetNextBucketDataKey( any iterator ) Parameters Parameter Description iterator The iterator you want to retrieve the key from. Returns: The next key, or null if no more keys are available. Example string key = pccGetNextBucketDataKey(myIterator); will return the next key from the iterator named myIterator . pccGetNextBucketDataKeys Retrieves several keys from the iterator. list<string> pccGetNextBucketDataKeys( any iterator [, int count] ) Parameters Parameter Description iterator The iterator you want to retrieve the keys from. count Optional parameter for controlling the maximum number of keys to retrieve. Returns: A list containing the retrieved keys. Example list<string> keys = pccGetNextBucketDataKeys(myIterator, 5); will return a list of maximum 5 keys with the name keys from the iterator named myIterator .

---

# Document 328: Netflow Meta Information Model - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204739692/Netflow+Meta+Information+Model
**Categories:** chunks_index.json

For information about the MIM and a list of the general MIM parameters, see Administration and Management in Legacy Desktop . Publishes MIM Parameter Description Incoming PDUs This MIM parameter contains the number of received packets. Incoming PDUs is of the long type and is defined as a global MIM context type. Accesses The agent does not access any MIM parameters.

---

# Document 329: Proprietary Formats - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205658039/Proprietary+Formats
**Categories:** chunks_index.json

Any kind of proprietary format, ASCII or binary based, is supported. The fields comprising the structure can be of the following types: Integer types (int, bigint, byte, short, long) Float types (float, double) Raw data  bytearray BCD encoded (bcd; read from left or right) ASCII or EBCDIC Fields can have size specifications (static or dynamic), or be defined to be separated by a specific character. Field separators can be based on any character, HEX or ASCII. Additionally, UDRs can contain other UDRs as well as lists of primitive or composite types, recursively.

---

# Document 330: TCP/IP Related UDR Types - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204609644/TCP+IP+Related+UDR+Types
**Categories:** chunks_index.json

TCPIPUDR The TCPIPUDR is the UDR type created by default in the TCPIP agent. It can be viewed in the UDR Internal Format Browser . To open the browser click Build  New Configuration  APL Code . In the editing area right-click and select UDR Assistance... to open the UDR Internal Format Browser . Open TCPIPUDR Field Description Field Description RemoteIP(ipaddress) The IP address of the client. RemotePort(int) The port through which the agent connects to the client. response(bytearray) The data that the agent sends back to the client. SequenceNumber(long) A per-connection unique number that is generated by the TCPIP agent. This number enables you to follow the order by which the UDRs are collected. The agent counter is reset whenever connection with the agent is established. The UDR fields RemoteIP , RemotePort , and SequenceNumber are accessible from the workflow configuration only if the TCP/IP agent is configured with a decoder that extends the built-in TCP/IP format. For further information see Decoder in the section Decoder Tab in TCP/IP Collection Agent Configuration . The TCPIPUDR cannot be cloned and the socket connection is not initialized if cloning is attempted. It is therefore recommended that you initialize every UDR from the decoder, and then route it into the workflow. TCPIPStateUDR You can configure the collection agent to track the connection state of the client. Whenever the client is connected or disconnected, the agent sends this UDR which contains the status of the connection each time it changes state. To activate this function, go to the TCP/IP tab and select the Send TCPIPStateUDR checkbox. See the TCP/IP Tab in TCP/IP Collection Agent Configuration . Open TCPIPStateUDR Field Description Field Description data (bytearray) This field is only populated when the collection agent tries to send a response to the client but the client is no longer connected. The agent then sends the TCPIPStateUDR back to the workflow with isConnected = false , and also including the response that APL wanted to send. During a normal state change, the value in the data field is null . ipAddress (string) The IP address of the client. isConnected (boolean) This field indicates if the client is connected or disconnected. When there is a new connection, this field is set to true . When a connection is terminated or disconnected, this field is set to false . port (int) The port of the client. response(bytearray) The data that the agent sends back to the client.

---

# Document 331: GTP' LGU ReCollection Agent Input/Output Data and MIM - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204673424/GTP+LGU+ReCollection+Agent+Input+Output+Data+and+MIM
**Categories:** chunks_index.json

Input/Output Data The Input/Output data is the type of data that an agent expects and delivers. The agent expects GTPRecollectionRequestUDR and produces GTPRecollectionResponseUDR. Meta Information Model For information about the MIM and a list of the general MIM parameters, see Administration and Management in Legacy Desktop . Publishes MIM Value Description MIM Value Description NE Host (String) This MIM value contains the IP address of the connected network element. NE Port (Int) This MIM value contains the port of the connected network element. Requests in queue (Int) This MIM value contains the number of queued requests to the connected network element. Accesses The agent does not access any MIM parameters.

---

# Document 332: APL - PCC Mapper Support - Buckets - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204611904/APL+-+PCC+Mapper+Support+-+Buckets
**Categories:** chunks_index.json

The mapper support is used for accessing a table in the products database containing references to the products that are applicable for the specified service. The mapper support functions include: 1 pccMapperCreate 2 pccMapperGet 3 pccMapperGetFlat 4 pccMapperGetIndex 5 pccMapperGetFromIndex Note! These functions can be used to create and use a PCC flexible mapper object. pccMapperCreate This function creates a mapper object. any pccMapperCreate ( string area , string typename [, string argumentsField , string targetField ] ) Parameters Parameter Description Parameter Description area The name of the area which the mapper is operating against. typename The fully qualified UDR typename to be used for the mapper configuration information. argumentsField The field name of the field that contains the argument list to be used for matching. This field must be a list of strings. Either null or the string "*" can be used to signify a wildcard matching. This field is optional. targetField The field name of the field that contains the target value. This is the value that should be returned from the pccMapperGet function. This field is optional. Returns: A mapper object that can be used in pccMapperGet . Example productMapping = pccMapperCreate ("PROD", "PCC.Products.Provisioning.ProductMapping"); will create a mapper object named productMapping that will use the PCC.Products.Provisioning.ProductMapping UDR type and operate against the PROD area. pccMapperGet This function will return a list of matching targets from PCC mapper objects, where the targets will be returned in priority order. list<any> pccMapperGet ( [any mapper,] any argument1 [, any argument2, ... ) Parameters Parameter Description Parameter Description mapper The mapper table in which you want to find matching targets. This field is optional. If no mapper is stated, the mapper last used by the workflow will be used for the lookup. argument...n Any number of arguments that you want the targets to match to match using the mapper object. The number of arguments must match the mapper configuration. Returns: A list with the matching target(s), or null if the mapper did not find any matching targets. Example list<any> myList = pccMapperGet(productMapping, 55) will return targets matching argument 55 in the productMapping mapper object. If there are five targets with the same priority; A, B, C, D, and E, and D and E matches argument 55, a list containing [D,E] will be returned. If there are three targets with priority 2; A, B, C, and three targets with priority 1; D, E and F, and targets B-E matches argument 55, a list containing lists for each priority will be returned displaying the matches in priority order; [[D,E],[B,C]]. pccMapperGetFlat This function will return a list of matching targets from PCC mapper objects, where the priority is not taken into consideration. list<any> pccMapperGetFlat ( [any mapper,] any argument1 [, any argument2, ... ) Parameters Parameter Description Parameter Description mapper The mapper table in which you want to find matching targets. This field is optional. If no mapper is stated, the mapper last used by the workflow will be used for the lookup. argument...n Any number of arguments that you want the targets to match to match using the mapper object. The number of arguments must match the mapper configuration. Returns: A list with the matching target(s), or null if the mapper did not find any matching targets. Example list<any> myList = pccMapperGetFlat(productMapping, 34); will return a list of the products named "GOLD" using the mapper table productMapping . No consideration is taken to priority, which means that if there are three targets with priority 2; A, B, C, and three targets with priority 1; D, E and F, and targets B-E matches argument 34, a single list containing all matching targets will be returned; [D,E,B,C]. pccMapperGetIndex This function will provide a list of all matching products with an index for each matching. This index may then be used by the pccMapperGetFromIndex function below for retrieving the products applicable for the actual object. list<any> pccMapperGetIndex ( [any mapper,] any argument1 [, any argument2, ... ) Parameters Parameter Description Parameter Description mapper The mapper object to be used for matching the arguments. This field is optional. If no mapper is stated, the mapper last used by the workflow will be used for the lookup. argument...n Any number of arguments to match using the mapper object. The number of arguments must match the mapper configuration. Returns: A list of the matching products with an index for each matching object, or null if the mapper did not match any data. Example list pccMapperGetIndex(productMapping,"GOLD"); will return a list of the products named "GOLD" using the mapper table productMapping , with an index for each matching object. pccMapperGetFromIndex This function will provide a list of products applicable for the stated object. list<any> pccMapperGetFromIndex ( any mapper,] int index ) Parameters Parameter Description Parameter Description mapper The mapper object to be used for matching the arguments. This field is optional. If no mapper is stated, the mapper last used by the workflow will be used for the lookup. index The index for the object that you want to retrieve products for. Returns: A list of products applicable for the object with the stated index.

---

# Document 333: Object Types - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205655952
**Categories:** chunks_index.json

This section describes the JSON representation of the various object types that are used in the service model storage. In order to run KPI Management, you must first provision a service model that includes all the required objects that are listed in the schema below. The following JSON schema describes the data format of a complete service model: Loading Note! The aggregated-output object type is optional and contains a boolean value that determines if the KPI output for each dimension will be grouped in the same KPIAggregatedOutput UDR. When the value of this object is set to true , multiple KPIOutput UDRs are grouped by dimension in the same KPIAggregatedOutput UDR. When the value is false (default), each KPI AggregatedOutput will contain one KPIOutput UDR. Example - Aggregated output "aggregated-output": true, ... When the value of aggregated-output is true, all kpi objects in the model must have the same window size. Other object types in the JSON schema are described in the following subsections. Note! When a service model contains objects of the same type and with identical names, only one of them will be used. Duplicate object definitions are not detected automatically when you validate the KPI profile. Loading

---

# Document 334: Diameter ABNF Specification Syntax - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/205032650/Diameter+ABNF+Specification+Syntax
**Categories:** chunks_index.json

The system uses the ABNF format defined in the Diameter Base Protocol RFC (RFC 6733). Example - ABNF Specification file CCR and CCA command specification for the Diameter Credit-Control application (Nortel GGSN): ccr_cca_abnf Example - The Diameter Command ABNF Specification - Copied from RFC 6733: Every Command Code that is defined must include a corresponding ABNF specification that is used to define the AVPs. The following format is used in the definition: command-def = command-name "::=" diameter-message command-name = diameter-name diameter-name = ALPHA *(ALPHA / DIGIT / "-") diameter-message = header [ *fixed] [ *required] [ *optional] [ *fixed] header = "<" Diameter-Header:" command-id [r-bit] [p-bit] [e-bit] [application-id]">" application-id = 1*DIGIT command-id = 1*DIGIT The Command Code assigned to the command r-bit = ", REQ" If present, the 'R' bit in the Command Flags is set, indicating that the message is a request, as opposed to an answer. p-bit = ", PXY" If present, the 'P' bit in the Command Flags is set, indicating that the message is proxiable. e-bit = ", ERR" If present, the 'E' bit in the Command Flags is set, indicating that the answer message contains a Result-Code AVP in the "protocol error" class. fixed = [qual] "<" avp-spec ">" Defines the fixed position of an AVP required = [qual] "{" avp-spec "}" The AVP MUST be present and can appear anywhere in the message. optional = [qual] "[" avp-name "]" The AVP-name in the 'optional' rule cannot evaluate to any AVP Name which is included in a fixed or required rule. The AVP can appear anywhere in the message. qual = [min] "*" [max] See ABNF conventions, RFC 2234 Section 6.6. The absence of any qualifiers depends on whether it precedes a fixed, required or optional rule. If a fixed or required rule has no qualifier, then exactly one such AVP MUST be present. If an optional rule has no qualifier, then 0 or 1 such AVP may be present. NOTE: "[" and "]" have a different meaning than in ABNF (see the optional rule, above). These braces cannot be used to express optional fixed rules (such as an optional ICV at the end). To do this, the convention is '0*1fixed'. min = 1*DIGIT The minimum number of times the element may be present. The default value is zero. max = 1*DIGIT The maximum number of times the element may be present. The default value is infinity. A value of zero implies the AVP MUST NOT be present. avp-spec = diameter-name The AVP-spec has to be an AVP Name, defined in the base or extended Diameter specifications. avp-name = avp-spec / "AVP" The string "AVP" stands for *any* arbitrary AVP Name, which does not conflict with the required or fixed position AVPs defined in the command code definition. The following is a definition of a fictitious command code: Example-Request ::= < "Diameter-Header: 9999999, REQ, PXY > { User-Name } * { Origin-Host } * [ AVP ]

---

# Document 335: Out-maps - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204678321/Out-maps
**Categories:** chunks_index.json

Out-maps are used in encoders to map an internal format to an external format. Example - out_map internal IFormat1 { int f1; ascii f2; }; external EFormat1 { ascii f1 : static_size(2), terminated_by(" "); ascii f2 : static_size(10), terminated_by(" "); }; out_map OutMap : internal(IFormat1), external(EFormat1) { automatic; }; The automatic mapping for out-maps only attempts to bind every field name of the external format to the respective internal format. Just as with the in-maps, no additional formats or fields are created. Like the in-maps, out-maps support explicit mappings. As for in-maps, specially named options can also be supplied in the out_map depending on the type of the external format. The type specific options are: Option Description Option Description PER_aligned Only applicable for ASN.1 based formats. Specifies that PER encoding (ALIGNED version) is to be used. PER_unaligned Only applicable for ASN.1 based formats. Specifies that PER encoding (UNALIGNED version) is to be used. Optional Fields There are some additional considerations for the case where optional external fields are encoded. An internal field can be defined as optional, enabling to encode the corresponding external field as not present. Internal fields with value null may still be considered present and are encoded as, for instance, an empty string. To override this, use the APL command udrUnsetPresent prior to encoding. Consider the following example, where an optional field within an incoming ASN.1 record is encoded (the definition of myInt varies). Example - Encoding Optional Fields asn_block { main_udr ::= SEQUENCE { fieldA [APPLICATION 5] INTEGER OPTIONAL }; }; in_map inM : external( main_udr ), internal( myInt ) { automatic; }; out_map outM : internal( myInt ), external( main_udr ) { automatic; }; decoder myDEC : in_map( inM ); encoder myENC : out_map( outM ); Case 1 - Optional internal field: If fieldA is defined as optional in the internal format definition, it will be present in the encoded record if it was present in the internal record, even if the value is null . It will not be present if it was not present in the internal record. internal myInt { int fieldA : optional; }; Case 2 - Mandatory internal field: If fieldA is defined as mandatory in the internal format definition, it is always present in the encoded record. internal myInt { int fieldA ; }; Case 3 - No mapped internal field: internal myInt { };

---

# Document 336: Couchbase Profile - MediationZone Documentation 9.3 - InfoZone

**Source:** ratanon/mz93-documentation
**URL:** https://infozone.atlassian.net/wiki/spaces/MD93/pages/204737565/Couchbase+Profile
**Categories:** chunks_index.json



---
**End of Part 16** - Continue to next part for more content.
